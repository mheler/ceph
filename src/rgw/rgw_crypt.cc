// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:nil -*-
// vim: ts=8 sw=2 sts=2 expandtab ft=cpp

/**
 * Crypto filters for Put/Post/Get operations.
 */

#include <string_view>

#include <rgw/rgw_op.h>
#include <rgw/rgw_crypt.h>
#include <auth/Crypto.h>
#include <rgw/rgw_b64.h>
#include <rgw/rgw_rest_s3.h>
#include "include/ceph_assert.h"
#include "include/function2.hpp"
#include "crypto/crypto_accel.h"
#include "crypto/crypto_plugin.h"
#include "rgw/rgw_kms.h"
#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/error/error.h"
#include "rapidjson/error/en.h"
#include <unicode/normalizer2.h>	// libicu

#include <openssl/evp.h>
#include <openssl/hmac.h>

#define dout_context g_ceph_context
#define dout_subsys ceph_subsys_rgw

using namespace std;
using namespace rgw;

template<typename M>
class canonical_char_sorter {
private:
    const DoutPrefixProvider *dpp;
    const icu::Normalizer2* normalizer;
    CephContext *cct;
public:
    canonical_char_sorter(const DoutPrefixProvider *dpp, CephContext *cct) : dpp(dpp), cct(cct) {
        UErrorCode status = U_ZERO_ERROR;
        normalizer = icu::Normalizer2::getNFCInstance(status);
        if (U_FAILURE(status)) {
            ldpp_dout(this->dpp, -1) << "ERROR: can't get nfc instance, error = " << status << dendl;
            normalizer = 0;
        }
    }
    bool compare_helper (const M *, const M *);
    bool make_string_canonical(rapidjson::Value &,
        rapidjson::Document::AllocatorType&);
};

template<typename M>
bool
canonical_char_sorter<M>::compare_helper (const M*a, const M*b)
{
    UErrorCode status = U_ZERO_ERROR;
    const std::string as{a->name.GetString(), a->name.GetStringLength()},
        bs{b->name.GetString(), b->name.GetStringLength()};
    icu::UnicodeString aw{icu::UnicodeString::fromUTF8(as)}, bw{icu::UnicodeString::fromUTF8(bs)};
    int32_t afl{ aw.countChar32()}, bfl{bw.countChar32()};
    std::u32string af, bf;
    af.resize(afl); bf.resize(bfl);
    auto *astr{af.c_str()}, *bstr{bf.c_str()};
    aw.toUTF32((int32_t*)astr, afl, status);
    bw.toUTF32((int32_t*)bstr, bfl, status);
    bool r{af < bf};
    return r;
}

template<typename M>
bool
canonical_char_sorter<M>::make_string_canonical (rapidjson::Value &v, rapidjson::Document::AllocatorType&a)
{
    UErrorCode status = U_ZERO_ERROR;
    const std::string as{v.GetString(), v.GetStringLength()};

    if (!normalizer)
        return false;
    const icu::UnicodeString aw{icu::UnicodeString::fromUTF8(as)};
    icu::UnicodeString an{normalizer->normalize(aw, status)};
    if (U_FAILURE(status)) {
        ldpp_dout(this->dpp, 5) << "conversion error; code=" << status <<
            " on string " << as << dendl;
        return false;
    }
    std::string ans;
    an.toUTF8String(ans);
    v.SetString(ans.c_str(), ans.length(), a);
    return true;
}

typedef
rapidjson::GenericMember<rapidjson::UTF8<>, rapidjson::MemoryPoolAllocator<> >
MyMember;

template<typename H>
bool
sort_and_write(rapidjson::Value &d, H &writer, canonical_char_sorter<MyMember>& ccs)
{
    bool r;
    switch(d.GetType()) {
    case rapidjson::kObjectType: {
    struct comparer {
        canonical_char_sorter<MyMember> &r;
        comparer(canonical_char_sorter<MyMember> &r) : r(r) {};
        bool operator()(const MyMember*a, const MyMember*b) {
            return r.compare_helper(a,b);
        }
    } cmp_functor{ccs};
        if (!(r = writer.StartObject()))
            break;
        std::vector<MyMember*> q;
        for (auto &m: d.GetObject())
            q.push_back(&m);
        std::sort(q.begin(), q.end(), cmp_functor);
        for (auto m: q) {
            assert(m->name.IsString());
            if (!(r = writer.Key(m->name.GetString(), m->name.GetStringLength())))
                goto Done;
            if (!(r = sort_and_write(m->value, writer, ccs)))
                goto Done;
        }
        r = writer.EndObject();
        break; }
    case rapidjson::kArrayType:
        if (!(r = writer.StartArray()))
            break;
        for (auto &v: d.GetArray()) {
            if (!(r = sort_and_write(v, writer, ccs)))
                goto Done;
        }
        r = writer.EndArray();
        break;
    default:
        r = d.Accept(writer);
        break;
    }
Done:
    return r;
}

enum struct mec_option {
empty = 0, number_ok = 1
};

enum struct mec_error {
success = 0, conversion, number
};

mec_error
make_everything_canonical(rapidjson::Value &d, rapidjson::Document::AllocatorType&a, canonical_char_sorter<MyMember>& ccs, mec_option f = mec_option::empty )
{
    mec_error r;
    switch(d.GetType()) {
    case rapidjson::kObjectType:
        for (auto &m: d.GetObject()) {
            assert(m.name.IsString());
            if (!ccs.make_string_canonical(m.name, a)) {
                r = mec_error::conversion;
                goto Error;
            }
            if ((r = make_everything_canonical(m.value, a, ccs, f)) != mec_error::success)
                goto Error;
        }
        break;
    case rapidjson::kArrayType:
        for (auto &v: d.GetArray()) {
            if ((r = make_everything_canonical(v, a, ccs, f)) != mec_error::success)
                goto Error;
        }
        break;
    case rapidjson::kStringType:
        if (!ccs.make_string_canonical(d, a)) {
            r = mec_error::conversion;
            goto Error;
        }
        break;
    case rapidjson::kNumberType:
        if (static_cast<int>(f) & static_cast<int>(mec_option::number_ok))
            break;
        r = mec_error::number;
        goto Error;
    default:
        break;
    }
    r = mec_error::success;
Error:
    return r;
}

bool
add_object_to_context(rgw_obj &obj, rapidjson::Document &d)
{
    ARN a{obj};
    const char aws_s3_arn[] { "aws:s3:arn" };
    std::string as{a.to_string()};
    rapidjson::Document::AllocatorType &allocator { d.GetAllocator() };
    rapidjson::Value name, val;

    if (!d.IsObject())
        return false;
    if (d.HasMember(aws_s3_arn))
        return true;
    val.SetString(as.c_str(), as.length(), allocator);
    name.SetString(aws_s3_arn, sizeof aws_s3_arn - 1, allocator);
    d.AddMember(name, val, allocator);
    return true;
}

static inline const std::string &
get_tenant_or_id(req_state *s)
{
    const std::string &tenant{ s->user->get_tenant() };
    if (!tenant.empty()) return tenant;
    return s->user->get_id().id;
}

int
make_canonical_context(req_state *s,
    std::string_view &context,
    std::string &cooked_context)
{
    rapidjson::Document d;
    bool b = false;
mec_option options {
//mec_option::number_ok :	SEE BOTTOM OF FILE
mec_option::empty };
    rgw_obj obj;
    std::ostringstream oss;
    canonical_char_sorter<MyMember> ccs{s, s->cct};

    obj.bucket.tenant = get_tenant_or_id(s);
    obj.bucket.name = s->bucket->get_name();
    obj.key.name = s->object->get_name();
    std::string iline;
    rapidjson::Document::AllocatorType &allocator { d.GetAllocator() };

    try {
	iline = rgw::from_base64(context);
    } catch (const std::exception& e) {
	oss << "bad context: " << e.what();
	s->err.message = oss.str();
        return -ERR_INVALID_REQUEST;
    }
    rapidjson::StringStream isw(iline.c_str());
    if (!iline.length())
        d.SetObject();
//    else if (qflag)		SEE BOTTOM OF FILE
//       d.ParseStream<rapidjson::kParseNumbersAsStringsFlag>(isw);
    else
        d.ParseStream<rapidjson::kParseFullPrecisionFlag>(isw);
    if (isw.Tell() != iline.length()) {
        oss << "bad context: did not consume all of input: @ "
	    << isw.Tell();
	s->err.message = oss.str();
        return -ERR_INVALID_REQUEST;
    }
    if (d.HasParseError()) {
        oss << "bad context: parse error: @ " << d.GetErrorOffset()
	    << " " << rapidjson::GetParseError_En(d.GetParseError());
	s->err.message = oss.str();
        return -ERR_INVALID_REQUEST;
    }
    rapidjson::StringBuffer buf;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buf);
    if (!add_object_to_context(obj, d)) {
	ldpp_dout(s, -1) << "ERROR: can't add default value to context" << dendl;
	s->err.message = "context: internal error adding defaults";
        return -ERR_INVALID_REQUEST;
    }
    b = make_everything_canonical(d, allocator, ccs, options) == mec_error::success;
    if (!b) {
	ldpp_dout(s, -1) << "ERROR: can't make canonical json <"
	    << context << ">" << dendl;
	s->err.message = "context: can't make canonical";
        return -ERR_INVALID_REQUEST;
    }
    b = sort_and_write(d, writer, ccs);
    if (!b) {
	    ldpp_dout(s, 5) << "format error <" << context
	    << ">: partial.results=" << buf.GetString() << dendl;
	s->err.message = "unable to reformat json";
        return -ERR_INVALID_REQUEST;
    }
    cooked_context = rgw::to_base64(buf.GetString());
    return 0;
}


CryptoAccelRef get_crypto_accel(const DoutPrefixProvider* dpp, CephContext *cct, const size_t chunk_size, const size_t max_requests)
{
  CryptoAccelRef ca_impl = nullptr;
  stringstream ss;
  PluginRegistry *reg = cct->get_plugin_registry();
  string crypto_accel_type = cct->_conf->plugin_crypto_accelerator;

  CryptoPlugin *factory = dynamic_cast<CryptoPlugin*>(reg->get_with_load("crypto", crypto_accel_type));
  if (factory == nullptr) {
    ldpp_dout(dpp, -1) << __func__ << " cannot load crypto accelerator of type " << crypto_accel_type << dendl;
    return nullptr;
  }
  int err = factory->factory(&ca_impl, &ss, chunk_size, max_requests);
  if (err) {
    ldpp_dout(dpp, -1) << __func__ << " factory return error " << err <<
        " with description: " << ss.str() << dendl;
  }
  return ca_impl;
}


template <std::size_t KeySizeV, std::size_t IvSizeV>
static inline
bool evp_sym_transform(const DoutPrefixProvider* dpp,
                       CephContext* const cct,
                       const EVP_CIPHER* const type,
                       unsigned char* const out,
                       const unsigned char* const in,
                       const size_t size,
                       const unsigned char* const iv,
                       const unsigned char* const key,
                       const bool encrypt)
{
  using pctx_t = \
    std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)>;
  pctx_t pctx{ EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free };

  if (!pctx) {
    return false;
  }

  if (1 != EVP_CipherInit_ex(pctx.get(), type, nullptr,
                             nullptr, nullptr, encrypt)) {
    ldpp_dout(dpp, 5) << "EVP: failed to 1st initialization stage" << dendl;
    return false;
  }

  // we want to support ciphers that don't use IV at all like AES-256-ECB
  if constexpr (static_cast<bool>(IvSizeV)) {
    ceph_assert(EVP_CIPHER_CTX_iv_length(pctx.get()) == IvSizeV);
    ceph_assert(EVP_CIPHER_CTX_block_size(pctx.get()) == IvSizeV);
  }
  ceph_assert(EVP_CIPHER_CTX_key_length(pctx.get()) == KeySizeV);

  if (1 != EVP_CipherInit_ex(pctx.get(), nullptr, nullptr, key, iv, encrypt)) {
    ldpp_dout(dpp, 5) << "EVP: failed to 2nd initialization stage" << dendl;
    return false;
  }

  // disable padding
  if (1 != EVP_CIPHER_CTX_set_padding(pctx.get(), 0)) {
    ldpp_dout(dpp, 5) << "EVP: cannot disable PKCS padding" << dendl;
    return false;
  }

  // operate!
  int written = 0;
  ceph_assert(size <= static_cast<size_t>(std::numeric_limits<int>::max()));
  if (1 != EVP_CipherUpdate(pctx.get(), out, &written, in, size)) {
    ldpp_dout(dpp, 5) << "EVP: EVP_CipherUpdate failed" << dendl;
    return false;
  }

  int finally_written = 0;
  static_assert(sizeof(*out) == 1);
  if (1 != EVP_CipherFinal_ex(pctx.get(), out + written, &finally_written)) {
    ldpp_dout(dpp, 5) << "EVP: EVP_CipherFinal_ex failed" << dendl;
    return false;
  }

  // padding is disabled so EVP_CipherFinal_ex should not append anything
  ceph_assert(finally_written == 0);
  return (written + finally_written) == static_cast<int>(size);
}


/**
 * Encryption in CBC mode. Chunked to 4K blocks. Offset is used as IV for each 4K block.
 *
 *
 *
 * A. Encryption
 * 1. Input is split to 4K chunks + remainder in one, smaller chunk
 * 2. Each full chunk is encrypted separately with CBC chained mode, with initial IV derived from offset
 * 3. Last chunk is 16*m + n.
 * 4. 16*m bytes are encrypted with CBC chained mode, with initial IV derived from offset
 * 5. Last n bytes are xor-ed with pattern obtained by CBC encryption of
 *    last encrypted 16 byte block <16m-16, 16m-15) with IV = {0}.
 * 6. (Special case) If m == 0 then last n bytes are xor-ed with pattern
 *    obtained by CBC encryption of {0} with IV derived from offset
 *
 * B. Decryption
 * 1. Input is split to 4K chunks + remainder in one, smaller chunk
 * 2. Each full chunk is decrypted separately with CBC chained mode, with initial IV derived from offset
 * 3. Last chunk is 16*m + n.
 * 4. 16*m bytes are decrypted with CBC chained mode, with initial IV derived from offset
 * 5. Last n bytes are xor-ed with pattern obtained by CBC ENCRYPTION of
 *    last (still encrypted) 16 byte block <16m-16,16m-15) with IV = {0}
 * 6. (Special case) If m == 0 then last n bytes are xor-ed with pattern
 *    obtained by CBC ENCRYPTION of {0} with IV derived from offset
 */
class AES_256_CBC : public BlockCrypt {
public:
  static const size_t AES_256_KEYSIZE = 256 / 8;
  static const size_t AES_256_IVSIZE = 128 / 8;
  static const size_t CHUNK_SIZE = 4096;
  static const size_t QAT_MIN_SIZE = 65536;
  const DoutPrefixProvider* dpp;
private:
  static const uint8_t IV[AES_256_IVSIZE];
  CephContext* cct;
  uint8_t key[AES_256_KEYSIZE];
public:
  explicit AES_256_CBC(const DoutPrefixProvider* dpp, CephContext* cct): dpp(dpp), cct(cct) {
  }
  ~AES_256_CBC() {
    ::ceph::crypto::zeroize_for_security(key, AES_256_KEYSIZE);
  }
  bool set_key(const uint8_t* _key, size_t key_size) {
    if (key_size != AES_256_KEYSIZE) {
      return false;
    }
    memcpy(key, _key, AES_256_KEYSIZE);
    return true;
  }
  size_t get_block_size() {
    return CHUNK_SIZE;
  }

  bool cbc_transform(unsigned char* out,
                     const unsigned char* in,
                     const size_t size,
                     const unsigned char (&iv)[AES_256_IVSIZE],
                     const unsigned char (&key)[AES_256_KEYSIZE],
                     bool encrypt)
  {
    return evp_sym_transform<AES_256_KEYSIZE, AES_256_IVSIZE>(
      dpp, cct, EVP_aes_256_cbc(), out, in, size, iv, key, encrypt);
  }

  bool cbc_transform(unsigned char* out,
                     const unsigned char* in,
                     size_t size,
                     off_t stream_offset,
                     const unsigned char (&key)[AES_256_KEYSIZE],
                     bool encrypt,
                     optional_yield y)
  {
    static std::atomic<bool> failed_to_get_crypto(false);
    CryptoAccelRef crypto_accel;
    if (! failed_to_get_crypto.load())
    {
      static size_t max_requests = g_ceph_context->_conf->rgw_thread_pool_size;
      crypto_accel = get_crypto_accel(this->dpp, cct, CHUNK_SIZE, max_requests);
      if (!crypto_accel)
        failed_to_get_crypto = true;
    }
    bool result = false;
    static std::string accelerator = cct->_conf->plugin_crypto_accelerator;
    if (accelerator == "crypto_qat" && crypto_accel != nullptr && size >= QAT_MIN_SIZE) {
      // now, batch mode is only for QAT plugin
      size_t iv_num = size / CHUNK_SIZE;
      if (size % CHUNK_SIZE) ++iv_num;
      auto iv = new unsigned char[iv_num][AES_256_IVSIZE];
      for (size_t offset = 0, i = 0; offset < size; offset += CHUNK_SIZE, i++) {
        prepare_iv(iv[i], stream_offset + offset);
      }
      if (encrypt) {
        result = crypto_accel->cbc_encrypt_batch(out, in, size, iv, key, y);
      } else {
        result = crypto_accel->cbc_decrypt_batch(out, in, size, iv, key, y);
      }
      delete[] iv;
    }
    if (result == false) {
      // If QAT don't have free instance, we can fall back to this
      result = true;
      unsigned char iv[AES_256_IVSIZE];
      for (size_t offset = 0; result && (offset < size); offset += CHUNK_SIZE) {
        size_t process_size = offset + CHUNK_SIZE <= size ? CHUNK_SIZE : size - offset;
        prepare_iv(iv, stream_offset + offset);
        if (crypto_accel != nullptr && accelerator != "crypto_qat") {
          if (encrypt) {
            result = crypto_accel->cbc_encrypt(out + offset, in + offset,
                                              process_size, iv, key, y);
          } else {
            result = crypto_accel->cbc_decrypt(out + offset, in + offset,
                                              process_size, iv, key, y);
          }
        } else {
          result = cbc_transform(
              out + offset, in + offset, process_size,
              iv, key, encrypt);
        }
      }
    }
    return result;
  }


  bool encrypt(bufferlist& input,
               off_t in_ofs,
               size_t size,
               bufferlist& output,
               off_t stream_offset,
               optional_yield y)
  {
    bool result = false;
    size_t aligned_size = size / AES_256_IVSIZE * AES_256_IVSIZE;
    size_t unaligned_rest_size = size - aligned_size;
    output.clear();
    buffer::ptr buf(aligned_size + AES_256_IVSIZE);
    unsigned char* buf_raw = reinterpret_cast<unsigned char*>(buf.c_str());
    const unsigned char* input_raw = reinterpret_cast<const unsigned char*>(input.c_str());

    /* encrypt main bulk of data */
    result = cbc_transform(buf_raw,
                           input_raw + in_ofs,
                           aligned_size,
                           stream_offset, key, true, y);
    if (result && (unaligned_rest_size > 0)) {
      /* remainder to encrypt */
      if (aligned_size % CHUNK_SIZE > 0) {
        /* use last chunk for unaligned part */
        unsigned char iv[AES_256_IVSIZE] = {0};
        result = cbc_transform(buf_raw + aligned_size,
                               buf_raw + aligned_size - AES_256_IVSIZE,
                               AES_256_IVSIZE,
                               iv, key, true);
      } else {
        /* 0 full blocks in current chunk, use IV as base for unaligned part */
        unsigned char iv[AES_256_IVSIZE] = {0};
        unsigned char data[AES_256_IVSIZE];
        prepare_iv(data, stream_offset + aligned_size);
        result = cbc_transform(buf_raw + aligned_size,
                               data,
                               AES_256_IVSIZE,
                               iv, key, true);
      }
      if (result) {
        for(size_t i = aligned_size; i < size; i++) {
          *(buf_raw + i) ^= *(input_raw + in_ofs + i);
        }
      }
    }
    if (result) {
      ldpp_dout(this->dpp, 25) << "Encrypted " << size << " bytes"<< dendl;
      buf.set_length(size);
      output.append(buf);
    } else {
      ldpp_dout(this->dpp, 5) << "Failed to encrypt" << dendl;
    }
    return result;
  }


  bool decrypt(bufferlist& input,
               off_t in_ofs,
               size_t size,
               bufferlist& output,
               off_t stream_offset,
               optional_yield y)
  {
    bool result = false;
    size_t aligned_size = size / AES_256_IVSIZE * AES_256_IVSIZE;
    size_t unaligned_rest_size = size - aligned_size;
    output.clear();
    buffer::ptr buf(aligned_size + AES_256_IVSIZE);
    unsigned char* buf_raw = reinterpret_cast<unsigned char*>(buf.c_str());
    unsigned char* input_raw = reinterpret_cast<unsigned char*>(input.c_str());

    /* decrypt main bulk of data */
    result = cbc_transform(buf_raw,
                           input_raw + in_ofs,
                           aligned_size,
                           stream_offset, key, false, y);
    if (result && unaligned_rest_size > 0) {
      /* remainder to decrypt */
      if (aligned_size % CHUNK_SIZE > 0) {
        /*use last chunk for unaligned part*/
        unsigned char iv[AES_256_IVSIZE] = {0};
        result = cbc_transform(buf_raw + aligned_size,
                               input_raw + in_ofs + aligned_size - AES_256_IVSIZE,
                               AES_256_IVSIZE,
                               iv, key, true);
      } else {
        /* 0 full blocks in current chunk, use IV as base for unaligned part */
        unsigned char iv[AES_256_IVSIZE] = {0};
        unsigned char data[AES_256_IVSIZE];
        prepare_iv(data, stream_offset + aligned_size);
        result = cbc_transform(buf_raw + aligned_size,
                               data,
                               AES_256_IVSIZE,
                               iv, key, true);
      }
      if (result) {
        for(size_t i = aligned_size; i < size; i++) {
          *(buf_raw + i) ^= *(input_raw + in_ofs + i);
        }
      }
    }
    if (result) {
      ldpp_dout(this->dpp, 25) << "Decrypted " << size << " bytes"<< dendl;
      buf.set_length(size);
      output.append(buf);
    } else {
      ldpp_dout(this->dpp, 5) << "Failed to decrypt" << dendl;
    }
    return result;
  }


  void prepare_iv(unsigned char (&iv)[AES_256_IVSIZE], off_t offset) {
    off_t index = offset / AES_256_IVSIZE;
    off_t i = AES_256_IVSIZE - 1;
    unsigned int val;
    unsigned int carry = 0;
    while (i>=0) {
      val = (index & 0xff) + IV[i] + carry;
      iv[i] = val;
      carry = val >> 8;
      index = index >> 8;
      i--;
    }
  }
};


std::unique_ptr<BlockCrypt> AES_256_CBC_create(const DoutPrefixProvider* dpp, CephContext* cct, const uint8_t* key, size_t len)
{
  auto cbc = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(dpp, cct));
  cbc->set_key(key, AES_256_KEYSIZE);
  return cbc;
}


const uint8_t AES_256_CBC::IV[AES_256_CBC::AES_256_IVSIZE] =
    { 'a', 'e', 's', '2', '5', '6', 'i', 'v', '_', 'c', 't', 'r', '1', '3', '3', '7' };


/**
 * AES-256-GCM encryption implementation
 * Provides authenticated encryption with 96-bit IVs and 128-bit authentication tags
 */
class AES_256_GCM : public BlockCrypt {
public:
  static const size_t AES_256_KEYSIZE = 256 / 8;        // 32 bytes
  static const size_t AES_256_IVSIZE = 96 / 8;          // 12 bytes (GCM standard)
  static const size_t GCM_TAG_SIZE = 128 / 8;           // 16 bytes
  static const size_t CHUNK_SIZE = 4096;
  static const size_t ENCRYPTED_CHUNK_SIZE = CHUNK_SIZE + GCM_TAG_SIZE; // 4112

  const DoutPrefixProvider* dpp;
private:
  CephContext* cct;
  uint8_t key[AES_256_KEYSIZE];
  uint8_t base_key[AES_256_KEYSIZE];  // For SSE-C: stores object key before part derivation
  bool has_base_key = false;          // True if base_key is valid (SSE-C with key derivation)
  uint8_t base_nonce[AES_256_IVSIZE];
  bool nonce_initialized = false;
  uint32_t part_number_ = 0;  // For multipart: ensures unique IVs across parts

public:
  explicit AES_256_GCM(const DoutPrefixProvider* dpp, CephContext* cct)
    : dpp(dpp), cct(cct) {
    memset(base_nonce, 0, AES_256_IVSIZE);
  }

  ~AES_256_GCM() {
    ::ceph::crypto::zeroize_for_security(key, AES_256_KEYSIZE);
    ::ceph::crypto::zeroize_for_security(base_key, AES_256_KEYSIZE);
    ::ceph::crypto::zeroize_for_security(base_nonce, AES_256_IVSIZE);
  }

  bool set_key(const uint8_t* _key, size_t key_size) {
    if (key_size != AES_256_KEYSIZE) {
      return false;
    }
    memcpy(key, _key, AES_256_KEYSIZE);
    return true;
  }

  /**
   * Generate a random base nonce for this object.
   * Called during encryption to create a unique nonce per object.
   */
  bool generate_nonce() {
    cct->random()->get_bytes(reinterpret_cast<char*>(base_nonce), AES_256_IVSIZE);
    nonce_initialized = true;
    return true;
  }

  /**
   * Set the base nonce from a stored value.
   * Called during decryption to restore the object's nonce.
   */
  bool set_nonce(const uint8_t* nonce, size_t len) {
    if (len != AES_256_IVSIZE) {
      return false;
    }
    memcpy(base_nonce, nonce, AES_256_IVSIZE);
    nonce_initialized = true;
    return true;
  }

  /**
   * Get the base nonce for storage in object attributes.
   */
  std::string get_nonce() const {
    return std::string(reinterpret_cast<const char*>(base_nonce), AES_256_IVSIZE);
  }

  bool is_nonce_initialized() const {
    return nonce_initialized;
  }

  /**
   * Set part number for multipart IV derivation and key derivation (SSE-C).
   * Must be called before encrypt/decrypt for multipart uploads.
   *
   * For SSE-C mode (has_base_key=true): also re-derives the part-specific key
   * from base_key, enabling correct decryption when switching between parts
   * during multipart GET operations.
   */
  void set_part_number(uint32_t part_number) override {
    this->part_number_ = part_number;

    // For SSE-C mode, also derive the correct part key
    if (has_base_key && part_number > 0) {
      // Restore base key, then derive part key
      memcpy(this->key, this->base_key, AES_256_KEYSIZE);
      derive_part_key(part_number);
    } else if (has_base_key && part_number == 0) {
      // Part 0 means single-part or init - use base key directly
      memcpy(this->key, this->base_key, AES_256_KEYSIZE);
    }
    // For non-SSE-C modes (has_base_key=false), only IV derivation uses part_number
  }

  /**
   * Derive object-specific encryption key from user key + object identity.
   * This provides cryptographic binding between ciphertext and object identity:
   * - If object is moved/renamed at RADOS level → wrong key → decrypt fails
   * - If user context doesn't match → wrong key → decrypt fails
   *
   * Key derivation formula:
   *   ObjectKey = HMAC-SHA256(key, nonce || domain || bucket || object || version_id || user_context)
   *
   * @param user_key The user-provided encryption key (32 bytes)
   * @param key_len Length of user_key (must be 32)
   * @param bucket Bucket name
   * @param object Object name
   * @param version_id Version ID (empty for non-versioned objects)
   * @param user_context User-provided encryption context from header (may be empty)
   * @param part_number Part number for multipart uploads (0 for non-multipart)
   * @param domain Domain separator string for algorithm binding (e.g., "SSE-C-GCM", "RGW-AUTO-GCM")
   * @return true on success
   */
  bool derive_object_key(
      const uint8_t* user_key,
      size_t key_len,
      const std::string& bucket,
      const std::string& object,
      const std::string& version_id,
      const std::string& user_context,
      uint32_t part_number,
      const std::string& domain = "SSE-C-GCM")
  {
    if (key_len != AES_256_KEYSIZE) {
      ldpp_dout(dpp, 0) << "ERROR: derive_object_key: invalid key length "
                        << key_len << ", expected " << AES_256_KEYSIZE << dendl;
      return false;
    }
    if (!nonce_initialized) {
      ldpp_dout(dpp, 0) << "ERROR: derive_object_key: nonce not initialized" << dendl;
      return false;
    }

    // HMAC-SHA256(user_key, nonce || domain || bucket || object || version_id || user_context)
    HMAC_CTX* ctx = HMAC_CTX_new();
    if (!ctx) {
      ldpp_dout(dpp, 0) << "ERROR: derive_object_key: failed to create HMAC context" << dendl;
      return false;
    }

    if (1 != HMAC_Init_ex(ctx, user_key, key_len, EVP_sha256(), nullptr)) {
      ldpp_dout(dpp, 0) << "ERROR: derive_object_key: HMAC_Init_ex failed" << dendl;
      HMAC_CTX_free(ctx);
      return false;
    }

    // Helper to encode length as 4-byte big-endian and update HMAC
    // Length-prefixing prevents ambiguous concatenation attacks where
    // (object="foo", version="bar") could collide with (object="foobar", version="")
    auto hmac_update_with_length = [&ctx](const std::string_view& data) {
      uint32_t len = static_cast<uint32_t>(data.size());
      uint8_t len_buf[4] = {
        static_cast<uint8_t>((len >> 24) & 0xFF),
        static_cast<uint8_t>((len >> 16) & 0xFF),
        static_cast<uint8_t>((len >> 8) & 0xFF),
        static_cast<uint8_t>(len & 0xFF)
      };
      HMAC_Update(ctx, len_buf, 4);
      if (!data.empty()) {
        HMAC_Update(ctx, reinterpret_cast<const uint8_t*>(data.data()), data.size());
      }
    };

    // Include nonce in key derivation
    HMAC_Update(ctx, base_nonce, AES_256_IVSIZE);

    // Domain separator (length-prefixed for consistency)
    hmac_update_with_length(domain);

    // Include bucket/object/version_id/user_context with length prefixes
    // Format: nonce || len(domain) || domain || len(bucket) || bucket || len(object) || object
    //         || len(version_id) || version_id || len(user_context) || user_context
    hmac_update_with_length(bucket);
    hmac_update_with_length(object);
    hmac_update_with_length(version_id);
    hmac_update_with_length(user_context);

    unsigned int derived_len = 0;
    if (1 != HMAC_Final(ctx, this->key, &derived_len)) {
      ldpp_dout(dpp, 0) << "ERROR: derive_object_key: HMAC_Final failed" << dendl;
      HMAC_CTX_free(ctx);
      return false;
    }
    HMAC_CTX_free(ctx);

    if (derived_len != AES_256_KEYSIZE) {
      ldpp_dout(dpp, 0) << "ERROR: derive_object_key: unexpected derived key length "
                        << derived_len << dendl;
      return false;
    }

    // Store part_number for IV derivation (ensures unique IVs across parts)
    this->part_number_ = part_number;

    // Save base key for later part key derivation (needed for multipart GET)
    // This allows set_part_number() to re-derive the correct part key
    memcpy(this->base_key, this->key, AES_256_KEYSIZE);
    this->has_base_key = true;

    ldpp_dout(dpp, 20) << "derive_object_key: derived key for bucket=" << bucket
                       << " object=" << object
                       << " version_id=" << (version_id.empty() ? "(none)" : version_id)
                       << " user_context=" << (user_context.empty() ? "(none)" : "(provided)")
                       << " part_number=" << part_number << dendl;

    // For multipart, derive part-specific key
    if (part_number > 0) {
      return derive_part_key(part_number);
    }
    return true;
  }

  /**
   * Derive part-specific key for multipart uploads.
   * This prevents part reordering/swapping attacks.
   *
   * Formula: PartKey = HMAC-SHA256(ObjectKey, part_number)
   *
   * @param part_number Part number (1-based, as per S3 multipart API)
   * @return true on success
   */
  bool derive_part_key(uint32_t part_number) {
    // Encode part number as big-endian 4 bytes
    uint8_t part_bytes[4];
    part_bytes[0] = (part_number >> 24) & 0xFF;
    part_bytes[1] = (part_number >> 16) & 0xFF;
    part_bytes[2] = (part_number >> 8) & 0xFF;
    part_bytes[3] = part_number & 0xFF;

    uint8_t derived[AES_256_KEYSIZE];
    unsigned int derived_len = 0;

    if (!HMAC(EVP_sha256(), this->key, AES_256_KEYSIZE,
              part_bytes, 4, derived, &derived_len)) {
      ldpp_dout(dpp, 0) << "ERROR: derive_part_key: HMAC failed" << dendl;
      return false;
    }

    if (derived_len != AES_256_KEYSIZE) {
      ldpp_dout(dpp, 0) << "ERROR: derive_part_key: unexpected derived key length "
                        << derived_len << dendl;
      return false;
    }

    memcpy(this->key, derived, AES_256_KEYSIZE);

    ldpp_dout(dpp, 20) << "derive_part_key: derived key for part " << part_number << dendl;
    return true;
  }

  size_t get_block_size() override {
    return CHUNK_SIZE;
  }

  size_t get_encrypted_block_size() override {
    return ENCRYPTED_CHUNK_SIZE;
  }

  /**
   * Encode chunk index as 8-byte big-endian AAD.
   * Binds ciphertext to stream position, preventing chunk reordering attacks.
   */
  static void encode_chunk_aad(uint8_t (&aad)[8], uint64_t chunk_index) {
    aad[0] = (chunk_index >> 56) & 0xFF;
    aad[1] = (chunk_index >> 48) & 0xFF;
    aad[2] = (chunk_index >> 40) & 0xFF;
    aad[3] = (chunk_index >> 32) & 0xFF;
    aad[4] = (chunk_index >> 24) & 0xFF;
    aad[5] = (chunk_index >> 16) & 0xFF;
    aad[6] = (chunk_index >> 8) & 0xFF;
    aad[7] = chunk_index & 0xFF;
  }

  bool gcm_encrypt_chunk(unsigned char* out,
                         const unsigned char* in,
                         size_t size,
                         const unsigned char (&iv)[AES_256_IVSIZE],
                         const unsigned char (&key)[AES_256_KEYSIZE],
                         unsigned char* tag,
                         uint64_t chunk_index)
  {
    using pctx_t = std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)>;
    pctx_t pctx{ EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free };

    if (!pctx) {
      ldpp_dout(dpp, 5) << "EVP: failed to create cipher context" << dendl;
      return false;
    }

    // 1st init: set cipher type
    if (1 != EVP_EncryptInit_ex(pctx.get(), EVP_aes_256_gcm(),
                                 nullptr, nullptr, nullptr)) {
      ldpp_dout(dpp, 5) << "EVP: failed to initialize GCM" << dendl;
      return false;
    }

    // Verify IV size (should be 12 bytes for GCM)
    if (EVP_CIPHER_CTX_iv_length(pctx.get()) != AES_256_IVSIZE) {
      ldpp_dout(dpp, 5) << "EVP: unexpected IV length "
                        << EVP_CIPHER_CTX_iv_length(pctx.get())
                        << " expected " << AES_256_IVSIZE << dendl;
      return false;
    }

    // 2nd init: set key and IV
    if (1 != EVP_EncryptInit_ex(pctx.get(), nullptr, nullptr, key, iv)) {
      ldpp_dout(dpp, 5) << "EVP: failed to set key/IV" << dendl;
      return false;
    }

    // Add AAD for chunk ordering protection
    uint8_t aad[8];
    encode_chunk_aad(aad, chunk_index);
    int aad_len = 0;
    if (1 != EVP_EncryptUpdate(pctx.get(), nullptr, &aad_len, aad, sizeof(aad))) {
      ldpp_dout(dpp, 5) << "EVP: failed to set AAD" << dendl;
      return false;
    }

    // Encrypt data (size is at most CHUNK_SIZE, well within int range for EVP API)
    int written = 0;
    ceph_assert(size <= CHUNK_SIZE);
    if (1 != EVP_EncryptUpdate(pctx.get(), out, &written, in, size)) {
      ldpp_dout(dpp, 5) << "EVP: EncryptUpdate failed" << dendl;
      return false;
    }

    // Finalize (GCM doesn't add padding, so finally_written should be 0)
    int finally_written = 0;
    if (1 != EVP_EncryptFinal_ex(pctx.get(), out + written, &finally_written)) {
      ldpp_dout(dpp, 5) << "EVP: EncryptFinal_ex failed" << dendl;
      return false;
    }

    // Get authentication tag
    if (1 != EVP_CIPHER_CTX_ctrl(pctx.get(), EVP_CTRL_GCM_GET_TAG,
                                  GCM_TAG_SIZE, tag)) {
      ldpp_dout(dpp, 5) << "EVP: failed to get GCM tag" << dendl;
      return false;
    }

    return (written + finally_written) == static_cast<int>(size);
  }

  bool gcm_decrypt_chunk(unsigned char* out,
                         const unsigned char* in,
                         size_t size,
                         const unsigned char (&iv)[AES_256_IVSIZE],
                         const unsigned char (&key)[AES_256_KEYSIZE],
                         const unsigned char* tag,
                         uint64_t chunk_index)
  {
    using pctx_t = std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)>;
    pctx_t pctx{ EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free };

    if (!pctx) {
      ldpp_dout(dpp, 5) << "EVP: failed to create cipher context" << dendl;
      return false;
    }

    // 1st init: set cipher type
    if (1 != EVP_DecryptInit_ex(pctx.get(), EVP_aes_256_gcm(),
                                 nullptr, nullptr, nullptr)) {
      ldpp_dout(dpp, 5) << "EVP: failed to initialize GCM" << dendl;
      return false;
    }

    // 2nd init: set key and IV
    if (1 != EVP_DecryptInit_ex(pctx.get(), nullptr, nullptr, key, iv)) {
      ldpp_dout(dpp, 5) << "EVP: failed to set key/IV" << dendl;
      return false;
    }

    // Add AAD for chunk ordering protection (must match encryption)
    uint8_t aad[8];
    encode_chunk_aad(aad, chunk_index);
    int aad_len = 0;
    if (1 != EVP_DecryptUpdate(pctx.get(), nullptr, &aad_len, aad, sizeof(aad))) {
      ldpp_dout(dpp, 5) << "EVP: failed to set AAD" << dendl;
      return false;
    }

    // Decrypt data (size is at most CHUNK_SIZE, well within int range for EVP API)
    int written = 0;
    ceph_assert(size <= CHUNK_SIZE);
    if (1 != EVP_DecryptUpdate(pctx.get(), out, &written, in, size)) {
      ldpp_dout(dpp, 5) << "EVP: DecryptUpdate failed" << dendl;
      return false;
    }

    // Set expected tag for verification
    if (1 != EVP_CIPHER_CTX_ctrl(pctx.get(), EVP_CTRL_GCM_SET_TAG,
                                  GCM_TAG_SIZE, const_cast<unsigned char*>(tag))) {
      ldpp_dout(dpp, 5) << "EVP: failed to set GCM tag" << dendl;
      return false;
    }

    // Finalize - this verifies the tag
    int finally_written = 0;
    if (1 != EVP_DecryptFinal_ex(pctx.get(), out + written, &finally_written)) {
      ldpp_dout(dpp, 5) << "EVP: DecryptFinal_ex failed - authentication failure" << dendl;
      return false;  // Tag verification failed
    }

    return (written + finally_written) == static_cast<int>(size);
  }

  bool encrypt(bufferlist& input,
               off_t in_ofs,
               size_t size,
               bufferlist& output,
               off_t stream_offset,
               optional_yield y) override
  {
    output.clear();

    // Calculate output size: each CHUNK_SIZE plaintext becomes CHUNK_SIZE + GCM_TAG_SIZE
    size_t num_full_chunks = size / CHUNK_SIZE;
    size_t remainder = size % CHUNK_SIZE;
    size_t output_size = num_full_chunks * ENCRYPTED_CHUNK_SIZE;
    if (remainder > 0) {
      output_size += remainder + GCM_TAG_SIZE;
    }

    buffer::ptr buf(output_size);
    unsigned char* buf_raw = reinterpret_cast<unsigned char*>(buf.c_str());
    const unsigned char* input_raw = reinterpret_cast<const unsigned char*>(
        input.c_str() + in_ofs);

    size_t out_pos = 0;

    // Process full chunks
    for (size_t offset = 0; offset < num_full_chunks * CHUNK_SIZE; offset += CHUNK_SIZE) {
      unsigned char iv[AES_256_IVSIZE];
      prepare_iv(iv, stream_offset + offset);
      uint64_t chunk_index = (stream_offset + offset) / CHUNK_SIZE;

      unsigned char* ciphertext = buf_raw + out_pos;
      unsigned char* tag = buf_raw + out_pos + CHUNK_SIZE;

      if (!gcm_encrypt_chunk(ciphertext, input_raw + offset, CHUNK_SIZE,
                             iv, key, tag, chunk_index)) {
        ldpp_dout(dpp, 5) << "Failed to encrypt chunk at offset " << offset << dendl;
        return false;
      }

      out_pos += ENCRYPTED_CHUNK_SIZE;
    }

    // Process remainder (if any)
    if (remainder > 0) {
      unsigned char iv[AES_256_IVSIZE];
      prepare_iv(iv, stream_offset + num_full_chunks * CHUNK_SIZE);
      uint64_t chunk_index = (stream_offset + num_full_chunks * CHUNK_SIZE) / CHUNK_SIZE;

      unsigned char* ciphertext = buf_raw + out_pos;
      unsigned char* tag = buf_raw + out_pos + remainder;

      if (!gcm_encrypt_chunk(ciphertext, input_raw + num_full_chunks * CHUNK_SIZE,
                             remainder, iv, key, tag, chunk_index)) {
        ldpp_dout(dpp, 5) << "Failed to encrypt final chunk" << dendl;
        return false;
      }
    }

    ldpp_dout(dpp, 25) << "GCM: Encrypted " << size << " bytes to "
                       << output_size << " bytes" << dendl;
    buf.set_length(output_size);
    output.append(buf);
    return true;
  }

  bool decrypt(bufferlist& input,
               off_t in_ofs,
               size_t size,
               bufferlist& output,
               off_t stream_offset,
               optional_yield y) override
  {
    output.clear();

    // Input is organized as encrypted chunks (ciphertext + tag)
    size_t num_full_chunks = size / ENCRYPTED_CHUNK_SIZE;
    size_t remainder = size % ENCRYPTED_CHUNK_SIZE;
    size_t output_size = num_full_chunks * CHUNK_SIZE;

    if (remainder > 0) {
      if (remainder <= GCM_TAG_SIZE) {
        ldpp_dout(dpp, 5) << "GCM: Invalid encrypted data size: " << size << dendl;
        return false;
      }
      output_size += remainder - GCM_TAG_SIZE;
    }

    buffer::ptr buf(output_size);
    unsigned char* buf_raw = reinterpret_cast<unsigned char*>(buf.c_str());
    unsigned char* input_raw = reinterpret_cast<unsigned char*>(
        input.c_str() + in_ofs);

    size_t in_pos = 0;
    size_t out_pos = 0;

    // Process full chunks
    for (size_t i = 0; i < num_full_chunks; i++) {
      unsigned char iv[AES_256_IVSIZE];
      prepare_iv(iv, stream_offset + i * CHUNK_SIZE);
      uint64_t chunk_index = (stream_offset + i * CHUNK_SIZE) / CHUNK_SIZE;

      unsigned char* ciphertext = input_raw + in_pos;
      unsigned char* tag = input_raw + in_pos + CHUNK_SIZE;

      if (!gcm_decrypt_chunk(buf_raw + out_pos, ciphertext, CHUNK_SIZE,
                             iv, key, tag, chunk_index)) {
        ldpp_dout(dpp, 5) << "GCM: Failed to decrypt chunk " << i
                          << " - authentication failed" << dendl;
        return false;
      }

      in_pos += ENCRYPTED_CHUNK_SIZE;
      out_pos += CHUNK_SIZE;
    }

    // Process remainder (if any)
    if (remainder > 0) {
      size_t plaintext_size = remainder - GCM_TAG_SIZE;
      unsigned char iv[AES_256_IVSIZE];
      prepare_iv(iv, stream_offset + num_full_chunks * CHUNK_SIZE);
      uint64_t chunk_index = (stream_offset + num_full_chunks * CHUNK_SIZE) / CHUNK_SIZE;

      unsigned char* ciphertext = input_raw + in_pos;
      unsigned char* tag = input_raw + in_pos + plaintext_size;

      if (!gcm_decrypt_chunk(buf_raw + out_pos, ciphertext, plaintext_size,
                             iv, key, tag, chunk_index)) {
        ldpp_dout(dpp, 5) << "GCM: Failed to decrypt final chunk - authentication failed" << dendl;
        return false;
      }
    }

    ldpp_dout(dpp, 25) << "GCM: Decrypted " << size << " bytes to "
                       << output_size << " bytes" << dendl;
    buf.set_length(output_size);
    output.append(buf);
    return true;
  }

  /**
   * Derive per-chunk nonce from base_nonce + combined index.
   * This ensures each chunk has a unique nonce while maintaining
   * the "number used once" property required by GCM.
   *
   * For multipart uploads, we combine part_number and chunk_index to ensure
   * unique IVs across all parts (since each part's offset starts at 0).
   *
   * Combined index layout (64 bits):
   *   - Upper 24 bits: part_number (supports up to 16M parts; S3 limit is 10K)
   *   - Lower 40 bits: chunk_index (supports up to 1T chunks per part)
   */
  void prepare_iv(unsigned char (&iv)[AES_256_IVSIZE], off_t offset) {
    ceph_assert(nonce_initialized);

    // Combine part_number and chunk_index to ensure unique IVs across parts
    // Without this, multipart parts would reuse IVs (all start at offset 0)
    uint64_t chunk_index = offset / CHUNK_SIZE;
    uint64_t combined_index = (static_cast<uint64_t>(part_number_) << 40) | chunk_index;

    // Derive IV: base_nonce + combined_index (with carry propagation)
    int i = AES_256_IVSIZE - 1;
    unsigned int val;
    unsigned int carry = 0;

    while (i >= 0) {
      val = (combined_index & 0xff) + base_nonce[i] + carry;
      iv[i] = static_cast<unsigned char>(val);
      carry = val >> 8;
      combined_index = combined_index >> 8;
      i--;
    }
  }
};


/**
 * Create an AES-256-GCM BlockCrypt instance.
 *
 * For encryption: Pass nonce=nullptr to generate a random nonce.
 *                 After creation, call get_nonce() to retrieve it for storage.
 *
 * For decryption: Pass the stored nonce from RGW_ATTR_CRYPT_NONCE.
 */
std::unique_ptr<BlockCrypt> AES_256_GCM_create(const DoutPrefixProvider* dpp,
                                                CephContext* cct,
                                                const uint8_t* key,
                                                size_t key_len,
                                                const uint8_t* nonce,
                                                size_t nonce_len,
                                                uint32_t part_number)
{
  // Validate key_len to prevent OOB read if caller passes smaller buffer
  if (key_len != AES_256_GCM::AES_256_KEYSIZE) {
    ldpp_dout(dpp, 5) << "AES_256_GCM_create: invalid key size " << key_len
                      << ", expected " << AES_256_GCM::AES_256_KEYSIZE << dendl;
    return nullptr;
  }

  auto gcm = std::unique_ptr<AES_256_GCM>(new AES_256_GCM(dpp, cct));
  if (!gcm->set_key(key, key_len)) {
    return nullptr;
  }

  // Set part_number for multipart IV derivation (ensures unique IVs across parts)
  gcm->set_part_number(part_number);

  if (nonce != nullptr) {
    // Decryption path: use the provided stored nonce
    if (!gcm->set_nonce(nonce, nonce_len)) {
      ldpp_dout(dpp, 5) << "AES_256_GCM_create: invalid nonce size " << nonce_len << dendl;
      return nullptr;
    }
  } else {
    // Encryption path: generate a random nonce
    gcm->generate_nonce();
  }

  return gcm;
}


/**
 * Retrieve the nonce from a BlockCrypt instance for storage.
 * Returns empty string if the BlockCrypt is not an AES_256_GCM instance.
 */
std::string AES_256_GCM_get_nonce(BlockCrypt* block_crypt)
{
  auto* gcm = dynamic_cast<AES_256_GCM*>(block_crypt);
  if (gcm && gcm->is_nonce_initialized()) {
    return gcm->get_nonce();
  }
  return {};
}

/**
 * Test helper: derive object key for a BlockCrypt instance.
 * Returns true on success.
 */
bool AES_256_GCM_derive_object_key(BlockCrypt* block_crypt,
                                    const uint8_t* user_key,
                                    size_t key_len,
                                    const std::string& bucket,
                                    const std::string& object,
                                    const std::string& version_id,
                                    const std::string& user_context,
                                    uint32_t part_number,
                                    const std::string& domain)
{
  auto* gcm = dynamic_cast<AES_256_GCM*>(block_crypt);
  if (!gcm) {
    return false;
  }
  return gcm->derive_object_key(user_key, key_len, bucket, object,
                                 version_id, user_context, part_number, domain);
}


bool AES_256_ECB_encrypt(const DoutPrefixProvider* dpp,
                         CephContext* cct,
                         const uint8_t* key,
                         size_t key_size,
                         const uint8_t* data_in,
                         uint8_t* data_out,
                         size_t data_size)
{
  if (key_size == AES_256_KEYSIZE) {
    return evp_sym_transform<AES_256_KEYSIZE, 0 /* no IV in ECB */>(
      dpp, cct, EVP_aes_256_ecb(),  data_out, data_in, data_size,
      nullptr /* no IV in ECB */, key, true /* encrypt */);
  } else {
    ldpp_dout(dpp, 5) << "Key size must be 256 bits long" << dendl;
    return false;
  }
}


RGWGetObj_BlockDecrypt::RGWGetObj_BlockDecrypt(const DoutPrefixProvider *dpp,
                                               CephContext* cct,
                                               RGWGetObj_Filter* next,
                                               std::unique_ptr<BlockCrypt> crypt,
                                               std::vector<size_t> parts_len,
                                               optional_yield y)
    :
    RGWGetObj_Filter(next),
    dpp(dpp),
    cct(cct),
    crypt(std::move(crypt)),
    enc_begin_skip(0),
    ofs(0),
    enc_ofs(0),
    end(0),
    cache(),
    y(y),
    parts_len(std::move(parts_len))
{
  block_size = this->crypt->get_block_size();
  encrypted_block_size = this->crypt->get_encrypted_block_size();
}

RGWGetObj_BlockDecrypt::~RGWGetObj_BlockDecrypt() {
}

int RGWGetObj_BlockDecrypt::read_manifest_parts(const DoutPrefixProvider *dpp,
                                                const bufferlist& manifest_bl,
                                                std::vector<size_t>& parts_len)
{
  RGWObjManifest manifest;
  if (manifest_bl.length()) {
    auto miter = manifest_bl.cbegin();
    try {
      decode(manifest, miter);
    } catch (buffer::error& err) {
      ldpp_dout(dpp, 0) << "ERROR: couldn't decode manifest" << dendl;
      return -EIO;
    }
    RGWObjManifest::obj_iterator mi;
    for (mi = manifest.obj_begin(dpp); mi != manifest.obj_end(dpp); ++mi) {
      if (mi.get_cur_stripe() == 0) {
        parts_len.push_back(0);
      }
      parts_len.back() += mi.get_stripe_size();
    }
    for (size_t i = 0; i<parts_len.size(); i++) {
      ldpp_dout(dpp, 20) << "Manifest part " << i << ", size=" << parts_len[i] << dendl;
    }
  }
  return 0;
}

int RGWGetObj_BlockDecrypt::fixup_range(off_t& bl_ofs, off_t& bl_end) {
  off_t inp_ofs = bl_ofs;
  off_t inp_end = bl_end;

  // For size-expanding ciphers (GCM), we need to convert between logical and encrypted offsets.
  // Input bl_ofs/bl_end are logical (plaintext) offsets.
  // Output bl_ofs/bl_end must be encrypted (storage) offsets.
  const bool size_expanding = (block_size != encrypted_block_size);

  if (parts_len.size() > 0) {
    // Multipart object: work in plaintext offsets, then convert to encrypted.
    off_t in_ofs = bl_ofs;  // Will become plaintext offset within part i
    off_t in_end = bl_end;  // Will become plaintext offset within part j

    // Find part i containing in_ofs by subtracting plaintext sizes
    size_t i = 0;
    off_t cumulative_encrypted = 0;
    while (i < parts_len.size()) {
      size_t part_plaintext = encrypted_to_plaintext_size(parts_len[i]);
      if (in_ofs < (off_t)part_plaintext) {
        break;  // in_ofs is within part i
      }
      in_ofs -= part_plaintext;
      cumulative_encrypted += parts_len[i];
      i++;
    }
    // in_ofs is now plaintext offset within part i (or i==size if beyond all parts)

    // Find part j containing in_end (clamp to last part)
    size_t j = 0;
    off_t cumulative_encrypted_j = 0;
    while (j < (parts_len.size() - 1)) {
      size_t part_plaintext = encrypted_to_plaintext_size(parts_len[j]);
      if (in_end < (off_t)part_plaintext) {
        break;  // in_end is within part j
      }
      in_end -= part_plaintext;
      cumulative_encrypted_j += parts_len[j];
      j++;
    }
    // in_end is now plaintext offset within part j, j is always valid (clamped to last)

    // Block-align end within part j (in plaintext space, using plaintext block_size)
    size_t part_plaintext_j = encrypted_to_plaintext_size(parts_len[j]);
    size_t rounded_end = (in_end & ~(block_size - 1)) + (block_size - 1);
    if (rounded_end > part_plaintext_j - 1) {
      rounded_end = part_plaintext_j - 1;
    }

    // enc_begin_skip is offset within the block
    enc_begin_skip = in_ofs & (block_size - 1);
    ofs = bl_ofs - enc_begin_skip;
    end = bl_end;

    // Convert plaintext offsets to encrypted for output
    // For bl_end: convert rounded_end (plaintext within part j) to encrypted
    off_t enc_rounded_end = logical_to_encrypted_offset(rounded_end);
    if (enc_rounded_end > (off_t)parts_len[j] - 1) {
      enc_rounded_end = parts_len[j] - 1;
    }
    bl_end = cumulative_encrypted_j + enc_rounded_end;

    // For bl_ofs: convert aligned start to encrypted
    off_t aligned_in_ofs = in_ofs - enc_begin_skip;
    if (aligned_in_ofs < 0) aligned_in_ofs = 0;
    off_t enc_aligned_ofs = logical_to_encrypted_offset(aligned_in_ofs);
    bl_ofs = cumulative_encrypted + enc_aligned_ofs;

    // Original pattern: clamp bl_ofs to bl_end (handles invalid ranges)
    bl_ofs = std::min(bl_ofs, bl_end);

    // Track encrypted position for part boundary handling
    enc_ofs = bl_ofs;
  }
  else
  {
    // Simple object (no multipart)
    // enc_begin_skip is the offset within the logical block
    enc_begin_skip = bl_ofs & (block_size - 1);
    // ofs is the logical offset aligned to block boundary
    ofs = bl_ofs & ~(block_size - 1);
    enc_ofs = logical_to_encrypted_offset(ofs);  // Track encrypted position
    end = bl_end;

    // Calculate aligned logical range
    off_t aligned_logical_start = bl_ofs & ~(block_size - 1);
    off_t aligned_logical_end = (bl_end & ~(block_size - 1)) + (block_size - 1);

    // Convert to encrypted offsets for storage fetch
    bl_ofs = logical_to_encrypted_offset(aligned_logical_start);
    bl_end = logical_to_encrypted_offset(aligned_logical_end);

    // For GCM, ensure we fetch complete encrypted blocks (including tags)
    // Note: use division, not bitmask - encrypted_block_size may not be power of 2
    if (size_expanding) {
      bl_end = (bl_end / encrypted_block_size) * encrypted_block_size + (encrypted_block_size - 1);
    }
  }

  ldpp_dout(this->dpp, 20) << "fixup_range [" << inp_ofs << "," << inp_end
      << "] => [" << bl_ofs << "," << bl_end << "]"
      << " (block_size=" << block_size
      << ", encrypted_block_size=" << encrypted_block_size << ")" << dendl;

  if (next)
    return next->fixup_range(bl_ofs, bl_end);

  return 0;
}

int RGWGetObj_BlockDecrypt::process(bufferlist& in, size_t part_ofs, size_t size)
{
  bufferlist data;
  if (!crypt->decrypt(in, 0, size, data, part_ofs, y)) {
    return -ERR_INTERNAL_ERROR;
  }

  // data.length() is the decrypted (plaintext) size
  // For GCM: data.length() < size (due to tag removal)
  // For CBC: data.length() == size
  off_t decrypted_size = data.length();

  off_t send_size = decrypted_size - enc_begin_skip;
  if (ofs + enc_begin_skip + send_size > end + 1) {
    send_size = end + 1 - ofs - enc_begin_skip;
  }
  int res = next->handle_data(data, enc_begin_skip, send_size);
  enc_begin_skip = 0;
  ofs += decrypted_size;  // Advance plaintext position
  enc_ofs += size;        // Advance encrypted position (for part boundary tracking)
  in.splice(0, size);     // Remove encrypted data from input buffer
  return res;
}

int RGWGetObj_BlockDecrypt::handle_data(bufferlist& bl, off_t bl_ofs, off_t bl_len) {
  ldpp_dout(this->dpp, 25) << "Decrypt " << bl_len << " bytes"
      << " (encrypted_block_size=" << encrypted_block_size << ")" << dendl;
  bl.begin(bl_ofs).copy(bl_len, cache);

  int res = 0;

  // For part boundary tracking: use encrypted offset (parts_len has encrypted sizes)
  // For stream_offset to decrypt: use plaintext offset (for correct nonce derivation)
  size_t enc_part_ofs = enc_ofs;   // encrypted offset within current part
  size_t plain_part_ofs = ofs;     // plaintext offset within current part

  // Track which part we're in (part numbers are 1-based in multipart uploads)
  // Only switch part numbers for true multipart objects (parts_len.size() > 1).
  // Single-entry parts_len could be from manifest stripes of a non-multipart object,
  // which was encrypted with part_number=0. Setting part_number=1 would cause mismatch.
  const bool is_multipart = (parts_len.size() > 1);
  uint32_t part_idx = 0;
  for (size_t part : parts_len) {
    // Multipart part numbers are 1-based; non-multipart uses 0
    uint32_t this_part_num = is_multipart ? (part_idx + 1) : 0;

    if (enc_part_ofs >= part) {
      // We're past this part entirely, skip to next
      enc_part_ofs -= part;
      plain_part_ofs -= encrypted_to_plaintext_size(part);
      part_idx++;
    } else if (enc_part_ofs + cache.length() >= part) {
      // Ensure cipher has correct part number for this part
      if (is_multipart && current_part_num != this_part_num) {
        current_part_num = this_part_num;
        crypt->set_part_number(current_part_num);
      }

      // Data crosses a part boundary - process up to the boundary
      size_t enc_bytes_this_part = part - enc_part_ofs;
      res = process(cache, plain_part_ofs, enc_bytes_this_part);
      if (res < 0) {
        return res;
      }

      // Move to next part
      part_idx++;
      uint32_t next_part_num = is_multipart ? (part_idx + 1) : 0;
      if (is_multipart && part_idx < parts_len.size() && current_part_num != next_part_num) {
        current_part_num = next_part_num;
        crypt->set_part_number(current_part_num);
      }

      // Reset for next part (both offsets start at 0 within the new part)
      enc_part_ofs = 0;
      plain_part_ofs = 0;
    } else {
      // Ensure cipher has correct part number for this part
      if (is_multipart && current_part_num != this_part_num) {
        current_part_num = this_part_num;
        crypt->set_part_number(current_part_num);
      }
      break;
    }
  }

  // Process up to encrypted block boundaries
  // For GCM: need complete encrypted blocks (4112 bytes) to decrypt
  // For CBC: encrypted_block_size == block_size, so no change
  // Note: use division, not bitmask - encrypted_block_size may not be power of 2
  off_t aligned_size = (cache.length() / encrypted_block_size) * encrypted_block_size;
  if (aligned_size > 0) {
    res = process(cache, plain_part_ofs, aligned_size);
  }
  return res;
}

/**
 * flush remainder of data to output
 */
int RGWGetObj_BlockDecrypt::flush() {
  ldpp_dout(this->dpp, 25) << "Decrypt flushing " << cache.length() << " bytes" << dendl;
  int res = 0;

  // For part boundary tracking: use encrypted offset (parts_len has encrypted sizes)
  // For stream_offset to decrypt: use plaintext offset (for correct nonce derivation)
  size_t enc_part_ofs = enc_ofs;   // encrypted offset within current part
  size_t plain_part_ofs = ofs;     // plaintext offset within current part

  // Track which part we're in (part numbers are 1-based in multipart uploads)
  // Only switch part numbers for true multipart objects (parts_len.size() > 1).
  const bool is_multipart = (parts_len.size() > 1);
  uint32_t part_idx = 0;
  for (size_t part : parts_len) {
    // Multipart part numbers are 1-based; non-multipart uses 0
    uint32_t this_part_num = is_multipart ? (part_idx + 1) : 0;

    if (enc_part_ofs >= part) {
      // We're past this part entirely, skip to next
      enc_part_ofs -= part;
      plain_part_ofs -= encrypted_to_plaintext_size(part);
      part_idx++;
    } else if (enc_part_ofs + cache.length() >= part) {
      // Ensure cipher has correct part number for this part
      if (is_multipart && current_part_num != this_part_num) {
        current_part_num = this_part_num;
        crypt->set_part_number(current_part_num);
      }

      // Data crosses a part boundary - process up to the boundary
      size_t enc_bytes_this_part = part - enc_part_ofs;
      res = process(cache, plain_part_ofs, enc_bytes_this_part);
      if (res < 0) {
        return res;
      }

      // Move to next part
      part_idx++;
      uint32_t next_part_num = is_multipart ? (part_idx + 1) : 0;
      if (is_multipart && part_idx < parts_len.size() && current_part_num != next_part_num) {
        current_part_num = next_part_num;
        crypt->set_part_number(current_part_num);
      }

      // Reset for next part
      enc_part_ofs = 0;
      plain_part_ofs = 0;
    } else {
      // Ensure cipher has correct part number for this part
      if (is_multipart && current_part_num != this_part_num) {
        current_part_num = this_part_num;
        crypt->set_part_number(current_part_num);
      }
      break;
    }
  }

  // flush remaining data (possibly unaligned final block)
  if (cache.length() > 0) {
    res = process(cache, plain_part_ofs, cache.length());
    if (res < 0) {
      return res;
    }
  }

  if (next)
    return next->flush();

  return 0;
}

RGWPutObj_BlockEncrypt::RGWPutObj_BlockEncrypt(const DoutPrefixProvider *dpp,
                                               CephContext* cct,
                                               rgw::sal::DataProcessor *next,
                                               std::unique_ptr<BlockCrypt> crypt,
                                               optional_yield y)
  : Pipe(next),
    dpp(dpp),
    cct(cct),
    crypt(std::move(crypt)),
    block_size(this->crypt->get_block_size()),
    y(y)
{
}

int RGWPutObj_BlockEncrypt::process(bufferlist&& data, uint64_t logical_offset)
{
  ldpp_dout(this->dpp, 25) << "Encrypt " << data.length() << " bytes" << dendl;

  // adjust logical offset to beginning of cached data
  ceph_assert(logical_offset >= cache.length());
  logical_offset -= cache.length();

  const bool flush = (data.length() == 0);
  cache.claim_append(data);

  uint64_t proc_size = cache.length() & ~(block_size - 1);
  if (flush) {
    proc_size = cache.length();
  }
  if (proc_size > 0) {
    bufferlist in, out;
    cache.splice(0, proc_size, &in);
    if (!crypt->encrypt(in, 0, proc_size, out, logical_offset, y)) {
      return -ERR_INTERNAL_ERROR;
    }
    // For size-expanding ciphers (GCM), out.length() > proc_size
    // Use encrypted_offset for downstream writes, not plaintext logical_offset
    int r = Pipe::process(std::move(out), encrypted_offset);
    encrypted_offset += out.length();
    if (r < 0)
      return r;
  }

  if (flush) {
    /*replicate 0-sized handle_data*/
    return Pipe::process({}, encrypted_offset);
  }
  return 0;
}


std::string create_random_key_selector(CephContext * const cct) {
  char random[AES_256_KEYSIZE];
  cct->random()->get_bytes(&random[0], sizeof(random));
  return std::string(random, sizeof(random));
}

typedef enum {
  X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM=0,
  X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY,
  X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5,
  X_AMZ_SERVER_SIDE_ENCRYPTION,
  X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID,
  X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT,
  X_AMZ_SERVER_SIDE_ENCRYPTION_LAST
} crypt_option_e;
struct crypt_option_names {
  const std::string post_part_name;
};

static const crypt_option_names crypt_options[] = {
    {  "x-amz-server-side-encryption-customer-algorithm"},
    {        "x-amz-server-side-encryption-customer-key"},
    {    "x-amz-server-side-encryption-customer-key-md5"},
    {                     "x-amz-server-side-encryption"},
    {      "x-amz-server-side-encryption-aws-kms-key-id"},
    {             "x-amz-server-side-encryption-context"},
};

struct CryptAttributes {
  meta_map_t &x_meta_map;

  CryptAttributes(req_state *s)
    : x_meta_map(s->info.crypt_attribute_map) {
  }

  std::string_view get(crypt_option_e option)
  {
    static_assert(
	X_AMZ_SERVER_SIDE_ENCRYPTION_LAST == sizeof(crypt_options)/sizeof(*crypt_options),
	"Missing items in crypt_options");
    auto hdr { x_meta_map.find(crypt_options[option].post_part_name) };
    if (hdr != x_meta_map.end()) {
      return std::string_view(hdr->second);
    } else {
      return std::string_view();
    }
  }
};

std::string fetch_bucket_key_id(req_state *s)
{
  auto kek_iter = s->bucket_attrs.find(RGW_ATTR_BUCKET_ENCRYPTION_KEY_ID);
  if (kek_iter == s->bucket_attrs.end())
    return std::string();
  std::string a_key { kek_iter->second.to_str() };
  // early code appends a nul; pretend that didn't happen
  auto l { a_key.length() };
  if (l > 0 && a_key[l-1] == '\0') {
    a_key.resize(--l);
  }
  return a_key;
}

const std::string cant_expand_key{ "\uFFFD" };
std::string expand_key_name(req_state *s, const std::string_view&t)
{
  std::string r;
  size_t i, j;
  for (i = 0;;) {
    i = t.find('%', (j = i));
    if (i != j) {
      if (i == std::string_view::npos)
        r.append( t.substr(j) );
      else
        r.append( t.substr(j, i-j) );
    }
    if (i == std::string_view::npos) {
      break;
    }
    if (t[i+1] == '%') {
      r.append("%");
      i += 2;
      continue;
    }
    if (t.compare(i+1, 9, "bucket_id") == 0) {
      r.append(s->bucket->get_marker());
      i += 10;
      continue;
    }
    if (t.compare(i+1, 8, "owner_id") == 0) {
      r.append(std::visit(fu2::overload(
          [] (const rgw_user& user_id) -> const std::string& {
            return user_id.id;
          },
          [] (const rgw_account_id& account_id) -> const std::string& {
            return account_id;
          }), s->bucket->get_info().owner));
      i += 9;
      continue;
    }
    return cant_expand_key;
  }
  return r;
}

static int get_sse_s3_bucket_key(req_state *s, optional_yield y,
                                 std::string &key_id)
{
  int res;
  std::string saved_key;

  key_id = expand_key_name(s, s->cct->_conf->rgw_crypt_sse_s3_key_template);

  if (key_id == cant_expand_key) {
    ldpp_dout(s, 5) << "ERROR: unable to expand key_id " <<
      s->cct->_conf->rgw_crypt_sse_s3_key_template << " on bucket" << dendl;
    s->err.message = "Server side error - unable to expand key_id";
    return -EINVAL;
  }

  saved_key = fetch_bucket_key_id(s);
  if (saved_key != "") {
    ldpp_dout(s, 5) << "Found KEK ID: " << key_id << dendl;
  }
  if (saved_key != key_id) {
    res = create_sse_s3_bucket_key(s, key_id, y);
    if (res != 0) {
      return res;
    }
    bufferlist key_id_bl;
    key_id_bl.append(key_id.c_str(), key_id.length());
    for (int count = 0; count < 15; ++count) {
      rgw::sal::Attrs attrs = s->bucket->get_attrs();
      attrs[RGW_ATTR_BUCKET_ENCRYPTION_KEY_ID] = key_id_bl;
      res = s->bucket->merge_and_store_attrs(s, attrs, s->yield);
      if (res != -ECANCELED) {
        break;
      }
      res = s->bucket->try_refresh_info(s, nullptr, s->yield);
      if (res != 0) {
        break;
      }
    }
    if (res != 0) {
      ldpp_dout(s, 5) << "ERROR: unable to save new key_id on bucket" << dendl;
      s->err.message = "Server side error - unable to save key_id";
      return res;
    }
  }
  return 0;
}

int rgw_s3_prepare_encrypt(req_state* s, optional_yield y,
                           std::map<std::string, ceph::bufferlist>& attrs,
                           std::unique_ptr<BlockCrypt>* block_crypt,
                           std::map<std::string, std::string>& crypt_http_responses,
                           uint32_t part_number)
{
  int res = 0;
  CryptAttributes crypt_attributes { s };
  crypt_http_responses.clear();

  {
    std::string_view req_sse_ca =
        crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM);
    if (! req_sse_ca.empty()) {
      if (req_sse_ca != "AES256") {
        ldpp_dout(s, 5) << "ERROR: Invalid value for header "
                         << "x-amz-server-side-encryption-customer-algorithm"
                         << dendl;
        s->err.message = "The requested encryption algorithm is not valid, must be AES256.";
        return -ERR_INVALID_ENCRYPTION_ALGORITHM;
      }
      if (s->cct->_conf->rgw_crypt_require_ssl &&
          !rgw_transport_is_secure(s->cct, *s->info.env)) {
        ldpp_dout(s, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
        return -ERR_INVALID_REQUEST;
      }

      std::string key_bin;
      try {
        key_bin = from_base64(
          crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY) );
      } catch (...) {
        ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_encrypt invalid encryption "
                         << "key which contains character that is not base64 encoded."
                         << dendl;
        s->err.message = "Requests specifying Server Side Encryption with Customer "
                         "provided keys must provide an appropriate secret key.";
        return -EINVAL;
      }

      if (key_bin.size() != AES_256_CBC::AES_256_KEYSIZE) {
        ldpp_dout(s, 5) << "ERROR: invalid encryption key size" << dendl;
        s->err.message = "Requests specifying Server Side Encryption with Customer "
                         "provided keys must provide an appropriate secret key.";
        return -EINVAL;
      }

      std::string_view keymd5 =
          crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5);

      std::string keymd5_bin;
      try {
        keymd5_bin = from_base64(keymd5);
      } catch (...) {
        ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_encrypt invalid encryption key "
                         << "md5 which contains character that is not base64 encoded."
                         << dendl;
        s->err.message = "Requests specifying Server Side Encryption with Customer "
                         "provided keys must provide an appropriate secret key md5.";
        return -EINVAL;
      }

      if (keymd5_bin.size() != CEPH_CRYPTO_MD5_DIGESTSIZE) {
        ldpp_dout(s, 5) << "ERROR: Invalid key md5 size" << dendl;
        s->err.message = "Requests specifying Server Side Encryption with Customer "
                         "provided keys must provide an appropriate secret key md5.";
        return -EINVAL;
      }

      MD5 key_hash;
      // Allow use of MD5 digest in FIPS mode for non-cryptographic purposes
      key_hash.SetFlags(EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
      unsigned char key_hash_res[CEPH_CRYPTO_MD5_DIGESTSIZE];
      key_hash.Update(reinterpret_cast<const unsigned char*>(key_bin.c_str()), key_bin.size());
      key_hash.Final(key_hash_res);

      if (memcmp(key_hash_res, keymd5_bin.c_str(), CEPH_CRYPTO_MD5_DIGESTSIZE) != 0) {
        ldpp_dout(s, 5) << "ERROR: Invalid key md5 hash" << dendl;
        s->err.message = "The calculated MD5 hash of the key did not match the hash that was provided.";
        return -EINVAL;
      }

      set_attr(attrs, RGW_ATTR_CRYPT_KEYMD5, keymd5_bin);

      // Check config for encryption algorithm preference
      const bool use_gcm = (s->cct->_conf->rgw_crypt_sse_algorithm == "aes-256-gcm");

      if (use_gcm) {
        set_attr(attrs, RGW_ATTR_CRYPT_MODE, "SSE-C-AES256-GCM");

        // Parse encryption context if provided (for key derivation binding)
        std::string user_context;
        std::string_view context_header =
            crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT);
        if (!context_header.empty()) {
          if ((res = make_canonical_context(s, context_header, user_context))) {
            return res;
          }
          set_attr(attrs, RGW_ATTR_CRYPT_CONTEXT, user_context);
        }

        // Always generate and store nonce, even for multipart init (block_crypt=nullptr)
        // Each part upload will read this nonce from the upload metadata
        std::string nonce(AES_256_GCM_NONCE_SIZE, '\0');
        s->cct->random()->get_bytes(nonce.data(), AES_256_GCM_NONCE_SIZE);
        set_attr(attrs, RGW_ATTR_CRYPT_NONCE, nonce);

        if (block_crypt) {
          auto gcm = std::unique_ptr<AES_256_GCM>(new AES_256_GCM(s, s->cct));
          if (!gcm->set_nonce(reinterpret_cast<const uint8_t*>(nonce.c_str()), nonce.size())) {
            ldpp_dout(s, 5) << "ERROR: SSE-C-AES256-GCM encryption failed: "
                             << "could not initialize nonce" << dendl;
            return -EIO;
          }
          // Derive encryption key from user key + object identity
          std::string version_id = s->object ? s->object->get_instance() : "";
          if (!gcm->derive_object_key(
                  reinterpret_cast<const uint8_t*>(key_bin.c_str()),
                  AES_256_KEYSIZE,
                  s->bucket->get_name(),
                  s->object->get_name(),
                  version_id,
                  user_context,
                  part_number)) {
            ldpp_dout(s, 5) << "ERROR: SSE-C-AES256-GCM key derivation failed for "
                             << s->bucket->get_name() << "/" << s->object->get_name() << dendl;
            s->err.message = "Failed to derive encryption key.";
            return -EIO;
          }
          *block_crypt = std::move(gcm);
        }
      } else {
        set_attr(attrs, RGW_ATTR_CRYPT_MODE, "SSE-C-AES256");
        if (block_crypt) {
          auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
          aes->set_key(reinterpret_cast<const uint8_t*>(key_bin.c_str()), AES_256_KEYSIZE);
          *block_crypt = std::move(aes);
        }
      }

      crypt_http_responses["x-amz-server-side-encryption-customer-algorithm"] = "AES256";
      crypt_http_responses["x-amz-server-side-encryption-customer-key-MD5"] = std::string(keymd5);
      return 0;
    } else {
      std::string_view customer_key =
          crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY);
      if (!customer_key.empty()) {
        ldpp_dout(s, 5) << "ERROR: SSE-C encryption request is missing the header "
                         << "x-amz-server-side-encryption-customer-algorithm"
                         << dendl;
        s->err.message = "Requests specifying Server Side Encryption with Customer "
                         "provided keys must provide a valid encryption algorithm.";
        return -EINVAL;
      }

      std::string_view customer_key_md5 =
          crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5);
      if (!customer_key_md5.empty()) {
        ldpp_dout(s, 5) << "ERROR: SSE-C encryption request is missing the header "
                         << "x-amz-server-side-encryption-customer-algorithm"
                         << dendl;
        s->err.message = "Requests specifying Server Side Encryption with Customer "
                         "provided keys must provide a valid encryption algorithm.";
        return -EINVAL;
      }
    }

    /* AMAZON server side encryption with KMS (key management service) */
    std::string_view req_sse =
        crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION);
    if (! req_sse.empty()) {

      if (req_sse == "aws:kms") {
        if (s->cct->_conf->rgw_crypt_require_ssl &&
            !rgw_transport_is_secure(s->cct, *s->info.env)) {
          ldpp_dout(s, 5) << "ERROR: insecure request, rgw_crypt_require_ssl is set" << dendl;
          return -ERR_INVALID_REQUEST;
        }

        std::string_view context =
          crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_CONTEXT);
        std::string cooked_context;
        if ((res = make_canonical_context(s, context, cooked_context)))
          return res;
        std::string_view key_id =
          crypt_attributes.get(X_AMZ_SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID);
        if (key_id.empty()) {
          ldpp_dout(s, 5) << "ERROR: not provide a valid key id" << dendl;
          s->err.message = "Server Side Encryption with KMS managed key requires "
            "HTTP header x-amz-server-side-encryption-aws-kms-key-id";
          return -EINVAL;
        }
        /* try to retrieve actual key */
        if (s->cct->_conf->rgw_crypt_s3_kms_backend == RGW_SSE_KMS_BACKEND_TESTING) {
          std::string key_selector = create_random_key_selector(s->cct);
          set_attr(attrs, RGW_ATTR_CRYPT_KEYSEL, key_selector);
        }
        set_attr(attrs, RGW_ATTR_CRYPT_KEYID, key_id);
        set_attr(attrs, RGW_ATTR_CRYPT_CONTEXT, cooked_context);
        std::string actual_key;
        res = make_actual_key_from_kms(s, attrs, y, actual_key);
        if (res != 0) {
          ldpp_dout(s, 5) << "ERROR: failed to retrieve actual key from key_id: " << key_id << dendl;
          s->err.message = "Failed to retrieve the actual key, kms-keyid: " + std::string(key_id);
          return res;
        }
        if (actual_key.size() != AES_256_KEYSIZE) {
          ldpp_dout(s, 5) << "ERROR: key obtained from key_id:" <<
            key_id << " is not 256 bit size" << dendl;
          s->err.message = "KMS provided an invalid key for the given kms-keyid.";
          return -EINVAL;
        }

        const bool use_gcm = (s->cct->_conf->rgw_crypt_sse_algorithm == "aes-256-gcm");

        if (use_gcm) {
          set_attr(attrs, RGW_ATTR_CRYPT_MODE, "SSE-KMS-GCM");
          // Always generate and store nonce, even for multipart init (block_crypt=nullptr)
          std::string nonce(AES_256_GCM_NONCE_SIZE, '\0');
          s->cct->random()->get_bytes(nonce.data(), AES_256_GCM_NONCE_SIZE);
          set_attr(attrs, RGW_ATTR_CRYPT_NONCE, nonce);

          if (block_crypt) {
            auto aes = AES_256_GCM_create(s, s->cct,
                                           reinterpret_cast<const uint8_t*>(actual_key.c_str()),
                                           AES_256_KEYSIZE,
                                           reinterpret_cast<const uint8_t*>(nonce.c_str()),
                                           nonce.size(),
                                           part_number);
            if (!aes) {
              ldpp_dout(s, 5) << "ERROR: Failed to create AES-256-GCM instance" << dendl;
              ::ceph::crypto::zeroize_for_security(actual_key.data(), actual_key.length());
              return -EIO;
            }
            *block_crypt = std::move(aes);
          }
        } else {
          set_attr(attrs, RGW_ATTR_CRYPT_MODE, "SSE-KMS");
          if (block_crypt) {
            auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
            aes->set_key(reinterpret_cast<const uint8_t*>(actual_key.c_str()), AES_256_KEYSIZE);
            *block_crypt = std::move(aes);
          }
        }
        ::ceph::crypto::zeroize_for_security(actual_key.data(), actual_key.length());

        crypt_http_responses["x-amz-server-side-encryption"] = "aws:kms";
        crypt_http_responses["x-amz-server-side-encryption-aws-kms-key-id"] = std::string(key_id);
        crypt_http_responses["x-amz-server-side-encryption-context"] = std::move(cooked_context);
        return 0;
      } else if (req_sse != "AES256") {
        ldpp_dout(s, 5) << "ERROR: Invalid value for header x-amz-server-side-encryption"
                         << dendl;
        s->err.message = "Server Side Encryption with KMS managed key requires "
          "HTTP header x-amz-server-side-encryption : aws:kms or AES256";
        return -EINVAL;
      }

      if (s->cct->_conf->rgw_crypt_sse_s3_backend != "vault") {
        s->err.message = "Request specifies Server Side Encryption "
            "but server configuration does not support this.";
        return -EINVAL;
      }

      ldpp_dout(s, 5) << "RGW_ATTR_BUCKET_ENCRYPTION ALGO: "
              <<  req_sse << dendl;
      std::string_view context = "";
      std::string cooked_context;
      if ((res = make_canonical_context(s, context, cooked_context)))
        return res;

      std::string key_id;
      res = get_sse_s3_bucket_key(s, y, key_id);
      if (res != 0) {
        return res;
      }

      set_attr(attrs, RGW_ATTR_CRYPT_CONTEXT, cooked_context);
      set_attr(attrs, RGW_ATTR_CRYPT_KEYID, key_id);
      std::string actual_key;
      res = make_actual_key_from_sse_s3(s, attrs, y, actual_key);
      if (res != 0) {
        ldpp_dout(s, 5) << "ERROR: failed to retrieve actual key from key_id: " << key_id << dendl;
        s->err.message = "Failed to retrieve the actual key";
        return res;
      }
      if (actual_key.size() != AES_256_KEYSIZE) {
        ldpp_dout(s, 5) << "ERROR: key obtained from key_id:" <<
                       key_id << " is not 256 bit size" << dendl;
        s->err.message = "SSE-S3 provided an invalid key for the given keyid.";
        return -EINVAL;
      }

      const bool use_gcm = (s->cct->_conf->rgw_crypt_sse_algorithm == "aes-256-gcm");

      if (use_gcm) {
        set_attr(attrs, RGW_ATTR_CRYPT_MODE, "AES256-GCM");
        // Always generate and store nonce, even for multipart init (block_crypt=nullptr)
        std::string nonce(AES_256_GCM_NONCE_SIZE, '\0');
        s->cct->random()->get_bytes(nonce.data(), AES_256_GCM_NONCE_SIZE);
        set_attr(attrs, RGW_ATTR_CRYPT_NONCE, nonce);

        if (block_crypt) {
          auto aes = AES_256_GCM_create(s, s->cct,
                                         reinterpret_cast<const uint8_t*>(actual_key.c_str()),
                                         AES_256_KEYSIZE,
                                         reinterpret_cast<const uint8_t*>(nonce.c_str()),
                                         nonce.size(),
                                         part_number);
          if (!aes) {
            ldpp_dout(s, 5) << "ERROR: Failed to create AES-256-GCM instance" << dendl;
            ::ceph::crypto::zeroize_for_security(actual_key.data(), actual_key.length());
            return -EIO;
          }
          *block_crypt = std::move(aes);
        }
      } else {
        set_attr(attrs, RGW_ATTR_CRYPT_MODE, "AES256");
        if (block_crypt) {
          auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
          aes->set_key(reinterpret_cast<const uint8_t*>(actual_key.c_str()), AES_256_KEYSIZE);
          *block_crypt = std::move(aes);
        }
      }
      ::ceph::crypto::zeroize_for_security(actual_key.data(), actual_key.length());

      crypt_http_responses["x-amz-server-side-encryption"] = "AES256";

      return 0;
    } else if (s->cct->_conf->rgw_crypt_default_encryption_key != "") {
      std::string master_encryption_key;
      try {
        master_encryption_key = from_base64(s->cct->_conf->rgw_crypt_default_encryption_key);
      } catch (...) {
        ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_encrypt invalid default encryption key "
                         << "which contains character that is not base64 encoded."
                         << dendl;
        s->err.message = "Requests specifying Server Side Encryption with Customer "
                         "provided keys must provide an appropriate secret key.";
        return -EINVAL;
      }

      if (master_encryption_key.size() != 256 / 8) {
        ldpp_dout(s, 0) << "ERROR: failed to decode 'rgw crypt default encryption key' to 256 bit string" << dendl;
        /* not an error to return; missing encryption does not inhibit processing */
        return 0;
      }

      const bool use_gcm = (s->cct->_conf->rgw_crypt_sse_algorithm == "aes-256-gcm");

      if (use_gcm) {
        // GCM mode: use HMAC-SHA256 key derivation with context binding
        set_attr(attrs, RGW_ATTR_CRYPT_MODE, "RGW-AUTO-GCM");

        // Generate and store nonce (used for both IV derivation and key derivation)
        std::string nonce(AES_256_GCM_NONCE_SIZE, '\0');
        s->cct->random()->get_bytes(nonce.data(), AES_256_GCM_NONCE_SIZE);
        set_attr(attrs, RGW_ATTR_CRYPT_NONCE, nonce);

        if (block_crypt) {
          // Create GCM instance with nonce
          auto gcm = std::unique_ptr<AES_256_GCM>(new AES_256_GCM(s, s->cct));
          if (!gcm->set_nonce(reinterpret_cast<const uint8_t*>(nonce.c_str()), nonce.size())) {
            ldpp_dout(s, 5) << "ERROR: RGW-AUTO-GCM: could not initialize nonce" << dendl;
            return -EIO;
          }

          // Derive encryption key using HMAC-SHA256 with context binding
          // Key = HMAC-SHA256(master_key, nonce || "RGW-AUTO-GCM" || bucket || object || version_id)
          std::string version_id = s->object ? s->object->get_instance() : "";
          if (!gcm->derive_object_key(
                  reinterpret_cast<const uint8_t*>(master_encryption_key.c_str()),
                  AES_256_KEYSIZE,
                  s->bucket->get_name(),
                  s->object->get_name(),
                  version_id,
                  "",  // no user context for RGW-AUTO
                  part_number,
                  "RGW-AUTO-GCM")) {
            ldpp_dout(s, 5) << "ERROR: RGW-AUTO-GCM key derivation failed for "
                             << s->bucket->get_name() << "/" << s->object->get_name() << dendl;
            return -EIO;
          }
          *block_crypt = std::move(gcm);
        }
      } else {
        // CBC mode: use AES-ECB key derivation (legacy approach)
        std::string key_selector = create_random_key_selector(s->cct);
        set_attr(attrs, RGW_ATTR_CRYPT_KEYSEL, key_selector);

        uint8_t actual_key[AES_256_KEYSIZE];
        if (AES_256_ECB_encrypt(s, s->cct,
                                reinterpret_cast<const uint8_t*>(master_encryption_key.c_str()), AES_256_KEYSIZE,
                                reinterpret_cast<const uint8_t*>(key_selector.c_str()),
                                actual_key, AES_256_KEYSIZE) != true) {
          ::ceph::crypto::zeroize_for_security(actual_key, sizeof(actual_key));
          return -EIO;
        }

        set_attr(attrs, RGW_ATTR_CRYPT_MODE, "RGW-AUTO");
        if (block_crypt) {
          auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
          aes->set_key(actual_key, AES_256_KEYSIZE);
          *block_crypt = std::move(aes);
        }
        ::ceph::crypto::zeroize_for_security(actual_key, sizeof(actual_key));
      }
      return 0;
    }
  }
  return 0;
}


int rgw_s3_prepare_decrypt(req_state* s, optional_yield y,
                           map<string, bufferlist>& attrs,
                           std::unique_ptr<BlockCrypt>* block_crypt,
                           std::map<std::string, std::string>* crypt_http_responses,
                           bool copy_source,
                           uint32_t part_number)
{
  int res = 0;
  std::string stored_mode = get_str_attribute(attrs, RGW_ATTR_CRYPT_MODE);
  ldpp_dout(s, 15) << "Encryption mode: " << stored_mode << dendl;

  const char *req_sse = s->info.env->get("HTTP_X_AMZ_SERVER_SIDE_ENCRYPTION", NULL);
  if (nullptr != req_sse && (s->op == OP_GET || s->op == OP_HEAD)) {
    return -ERR_INVALID_REQUEST;
  }

  if (stored_mode == "SSE-C-AES256") {
    if (s->cct->_conf->rgw_crypt_require_ssl &&
        !rgw_transport_is_secure(s->cct, *s->info.env)) {
      ldpp_dout(s, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
      return -ERR_INVALID_REQUEST;
    }

    const char *sse_c_algo_hdr = copy_source ? "HTTP_X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM" :
                                               "HTTP_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM";
    const char *req_cust_alg = s->info.env->get(sse_c_algo_hdr, NULL);
    if (nullptr == req_cust_alg)  {
      ldpp_dout(s, 5) << "ERROR: Request for SSE-C encrypted object missing "
                       << "x-amz-server-side-encryption-customer-algorithm"
                       << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide a valid encryption algorithm.";
      return -EINVAL;
    } else if (strcmp(req_cust_alg, "AES256") != 0) {
      ldpp_dout(s, 5) << "ERROR: The requested encryption algorithm is not valid, must be AES256." << dendl;
      s->err.message = "The requested encryption algorithm is not valid, must be AES256.";
      return -ERR_INVALID_ENCRYPTION_ALGORITHM;
    }

    const char *sse_c_key_hdr = copy_source ? "HTTP_X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY" :
                                              "HTTP_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY";
    std::string key_bin;
    try {
      key_bin = from_base64(s->info.env->get(sse_c_key_hdr, ""));
    } catch (...) {
      ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_decrypt invalid encryption key "
                       << "which contains character that is not base64 encoded."
                       << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key.";
      return -EINVAL;
    }

    if (key_bin.size() != AES_256_CBC::AES_256_KEYSIZE) {
      ldpp_dout(s, 5) << "ERROR: Invalid encryption key size" << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key.";
      return -EINVAL;
    }

    const char *sse_c_key_md5_hdr = copy_source ? "HTTP_X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5" :
                                                  "HTTP_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5";
    std::string keymd5 = s->info.env->get(sse_c_key_md5_hdr, "");
    std::string keymd5_bin;
    try {
      keymd5_bin = from_base64(keymd5);
    } catch (...) {
      ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_decrypt invalid encryption key md5 "
                       << "which contains character that is not base64 encoded."
                       << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key md5.";
      return -EINVAL;
    }

    if (keymd5_bin.size() != CEPH_CRYPTO_MD5_DIGESTSIZE) {
      ldpp_dout(s, 5) << "ERROR: Invalid key md5 size " << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key md5.";
      return -EINVAL;
    }

    MD5 key_hash;
    // Allow use of MD5 digest in FIPS mode for non-cryptographic purposes
    key_hash.SetFlags(EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
    uint8_t key_hash_res[CEPH_CRYPTO_MD5_DIGESTSIZE];
    key_hash.Update(reinterpret_cast<const unsigned char*>(key_bin.c_str()), key_bin.size());
    key_hash.Final(key_hash_res);

    if ((memcmp(key_hash_res, keymd5_bin.c_str(), CEPH_CRYPTO_MD5_DIGESTSIZE) != 0) ||
        (get_str_attribute(attrs, RGW_ATTR_CRYPT_KEYMD5) != keymd5_bin)) {
      s->err.message = "The calculated MD5 hash of the key did not match the hash that was provided.";
      return -EINVAL;
    }
    auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
    aes->set_key(reinterpret_cast<const uint8_t*>(key_bin.c_str()), AES_256_CBC::AES_256_KEYSIZE);
    if (block_crypt) *block_crypt = std::move(aes);

    if (crypt_http_responses) {
      crypt_http_responses->emplace("x-amz-server-side-encryption-customer-algorithm", "AES256");
      crypt_http_responses->emplace("x-amz-server-side-encryption-customer-key-MD5", keymd5);
    }

    return 0;
  }

  if (stored_mode == "SSE-C-AES256-GCM") {
    if (s->cct->_conf->rgw_crypt_require_ssl &&
        !rgw_transport_is_secure(s->cct, *s->info.env)) {
      ldpp_dout(s, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
      return -ERR_INVALID_REQUEST;
    }

    const char *sse_c_algo_hdr = copy_source ? "HTTP_X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM" :
                                               "HTTP_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM";
    const char *req_cust_alg = s->info.env->get(sse_c_algo_hdr, NULL);
    if (nullptr == req_cust_alg)  {
      ldpp_dout(s, 5) << "ERROR: Request for SSE-C encrypted object missing "
                       << "x-amz-server-side-encryption-customer-algorithm"
                       << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide a valid encryption algorithm.";
      return -EINVAL;
    } else if (strcmp(req_cust_alg, "AES256") != 0) {
      ldpp_dout(s, 5) << "ERROR: The requested encryption algorithm is not valid, must be AES256." << dendl;
      s->err.message = "The requested encryption algorithm is not valid, must be AES256.";
      return -ERR_INVALID_ENCRYPTION_ALGORITHM;
    }

    const char *sse_c_key_hdr = copy_source ? "HTTP_X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY" :
                                              "HTTP_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY";
    std::string key_bin;
    try {
      key_bin = from_base64(s->info.env->get(sse_c_key_hdr, ""));
    } catch (...) {
      ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_decrypt invalid encryption key "
                       << "which contains character that is not base64 encoded."
                       << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key.";
      return -EINVAL;
    }

    if (key_bin.size() != AES_256_KEYSIZE) {
      ldpp_dout(s, 5) << "ERROR: Invalid encryption key size" << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key.";
      return -EINVAL;
    }

    const char *sse_c_key_md5_hdr = copy_source ? "HTTP_X_AMZ_COPY_SOURCE_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5" :
                                                  "HTTP_X_AMZ_SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5";
    std::string keymd5 = s->info.env->get(sse_c_key_md5_hdr, "");
    std::string keymd5_bin;
    try {
      keymd5_bin = from_base64(keymd5);
    } catch (...) {
      ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_decrypt invalid encryption key md5 "
                       << "which contains character that is not base64 encoded."
                       << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key md5.";
      return -EINVAL;
    }

    if (keymd5_bin.size() != CEPH_CRYPTO_MD5_DIGESTSIZE) {
      ldpp_dout(s, 5) << "ERROR: Invalid key md5 size " << dendl;
      s->err.message = "Requests specifying Server Side Encryption with Customer "
                       "provided keys must provide an appropriate secret key md5.";
      return -EINVAL;
    }

    MD5 key_hash;
    // Allow use of MD5 digest in FIPS mode for non-cryptographic purposes
    key_hash.SetFlags(EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
    uint8_t key_hash_res[CEPH_CRYPTO_MD5_DIGESTSIZE];
    key_hash.Update(reinterpret_cast<const unsigned char*>(key_bin.c_str()), key_bin.size());
    key_hash.Final(key_hash_res);

    if ((memcmp(key_hash_res, keymd5_bin.c_str(), CEPH_CRYPTO_MD5_DIGESTSIZE) != 0) ||
        (get_str_attribute(attrs, RGW_ATTR_CRYPT_KEYMD5) != keymd5_bin)) {
      s->err.message = "The calculated MD5 hash of the key did not match the hash that was provided.";
      return -EINVAL;
    }

    // Retrieve the stored nonce for decryption
    std::string stored_nonce = get_str_attribute(attrs, RGW_ATTR_CRYPT_NONCE);
    if (stored_nonce.size() != AES_256_GCM_NONCE_SIZE) {
      ldpp_dout(s, 5) << "ERROR: Missing or invalid nonce for SSE-C-AES256-GCM decryption" << dendl;
      s->err.message = "Object encryption metadata is corrupted.";
      return -EIO;
    }

    // Retrieve the stored user context (may be empty)
    std::string user_context = get_str_attribute(attrs, RGW_ATTR_CRYPT_CONTEXT);

    auto gcm = std::unique_ptr<AES_256_GCM>(new AES_256_GCM(s, s->cct));
    if (!gcm->set_nonce(reinterpret_cast<const uint8_t*>(stored_nonce.c_str()),
                        stored_nonce.size())) {
      ldpp_dout(s, 5) << "ERROR: SSE-C-AES256-GCM decryption failed: stored nonce has invalid size "
                       << stored_nonce.size() << " (expected " << AES_256_GCM_NONCE_SIZE << ")" << dendl;
      s->err.message = "Object encryption metadata is corrupted.";
      return -EIO;
    }
    // Re-derive encryption key from user key + object identity
    // For CopyObject, use the SOURCE object's identity (not destination)
    std::string bucket_name;
    std::string object_name;
    std::string version_id;
    if (copy_source && s->src_object) {
      bucket_name = s->src_bucket_name;
      object_name = s->src_object->get_name();
      version_id = s->src_object->get_instance();
    } else {
      bucket_name = s->bucket->get_name();
      object_name = s->object->get_name();
      version_id = s->object ? s->object->get_instance() : "";
    }
    if (!gcm->derive_object_key(
            reinterpret_cast<const uint8_t*>(key_bin.c_str()),
            AES_256_KEYSIZE,
            bucket_name,
            object_name,
            version_id,
            user_context,
            part_number)) {
      ldpp_dout(s, 5) << "ERROR: SSE-C-AES256-GCM key derivation failed for "
                       << bucket_name << "/" << object_name << dendl;
      s->err.message = "Failed to derive decryption key.";
      return -EIO;
    }
    if (block_crypt) *block_crypt = std::move(gcm);

    if (crypt_http_responses) {
      crypt_http_responses->emplace("x-amz-server-side-encryption-customer-algorithm", "AES256");
      crypt_http_responses->emplace("x-amz-server-side-encryption-customer-key-MD5", keymd5);
    }

    return 0;
  }

  if (stored_mode == "SSE-KMS") {
    if (s->cct->_conf->rgw_crypt_require_ssl &&
        !rgw_transport_is_secure(s->cct, *s->info.env)) {
      ldpp_dout(s, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
      return -ERR_INVALID_REQUEST;
    }
    /* try to retrieve actual key */
    std::string key_id = get_str_attribute(attrs, RGW_ATTR_CRYPT_KEYID);
    std::string actual_key;
    res = reconstitute_actual_key_from_kms(s, attrs, y, actual_key);
    if (res != 0) {
      ldpp_dout(s, 10) << "ERROR: failed to retrieve actual key from key_id: " << key_id << dendl;
      s->err.message = "Failed to retrieve the actual key, kms-keyid: " + key_id;
      return res;
    }
    if (actual_key.size() != AES_256_KEYSIZE) {
      ldpp_dout(s, 0) << "ERROR: key obtained from key_id:" <<
          key_id << " is not 256 bit size" << dendl;
      s->err.message = "KMS provided an invalid key for the given kms-keyid.";
      return -EINVAL;
    }

    auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
    aes->set_key(reinterpret_cast<const uint8_t*>(actual_key.c_str()), AES_256_KEYSIZE);
    actual_key.replace(0, actual_key.length(), actual_key.length(), '\000');
    if (block_crypt) *block_crypt = std::move(aes);

    if (crypt_http_responses) {
      crypt_http_responses->emplace("x-amz-server-side-encryption", "aws:kms");
      crypt_http_responses->emplace("x-amz-server-side-encryption-aws-kms-key-id", key_id);
    }

    return 0;
  }

  if (stored_mode == "SSE-KMS-GCM") {
    if (s->cct->_conf->rgw_crypt_require_ssl &&
        !rgw_transport_is_secure(s->cct, *s->info.env)) {
      ldpp_dout(s, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
      return -ERR_INVALID_REQUEST;
    }
    /* try to retrieve actual key */
    std::string key_id = get_str_attribute(attrs, RGW_ATTR_CRYPT_KEYID);
    std::string actual_key;
    res = reconstitute_actual_key_from_kms(s, attrs, y, actual_key);
    if (res != 0) {
      ldpp_dout(s, 10) << "ERROR: failed to retrieve actual key from key_id: " << key_id << dendl;
      s->err.message = "Failed to retrieve the actual key, kms-keyid: " + key_id;
      return res;
    }
    if (actual_key.size() != AES_256_KEYSIZE) {
      ldpp_dout(s, 0) << "ERROR: key obtained from key_id:" <<
          key_id << " is not 256 bit size" << dendl;
      s->err.message = "KMS provided an invalid key for the given kms-keyid.";
      return -EINVAL;
    }

    // Retrieve the stored nonce for decryption
    std::string stored_nonce = get_str_attribute(attrs, RGW_ATTR_CRYPT_NONCE);
    if (stored_nonce.size() != AES_256_GCM_NONCE_SIZE) {
      ldpp_dout(s, 5) << "ERROR: Missing or invalid nonce for SSE-KMS-GCM decryption" << dendl;
      actual_key.replace(0, actual_key.length(), actual_key.length(), '\000');
      s->err.message = "Object encryption metadata is corrupted.";
      return -EIO;
    }

    auto aes = AES_256_GCM_create(s, s->cct,
                                   reinterpret_cast<const uint8_t*>(actual_key.c_str()),
                                   AES_256_KEYSIZE,
                                   reinterpret_cast<const uint8_t*>(stored_nonce.c_str()),
                                   stored_nonce.size(),
                                   part_number);
    actual_key.replace(0, actual_key.length(), actual_key.length(), '\000');
    if (!aes) {
      ldpp_dout(s, 5) << "ERROR: Failed to create AES-256-GCM instance for decryption" << dendl;
      return -EIO;
    }
    if (block_crypt) *block_crypt = std::move(aes);

    if (crypt_http_responses) {
      crypt_http_responses->emplace("x-amz-server-side-encryption", "aws:kms");
      crypt_http_responses->emplace("x-amz-server-side-encryption-aws-kms-key-id", key_id);
    }

    return 0;
  }

  if (stored_mode == "RGW-AUTO") {
    std::string master_encryption_key;
    try {
      master_encryption_key = from_base64(std::string(s->cct->_conf->rgw_crypt_default_encryption_key));
    } catch (...) {
      ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_decrypt invalid default encryption key "
                       << "which contains character that is not base64 encoded."
                       << dendl;
      s->err.message = "The default encryption key is not valid base64.";
      return -EINVAL;
    }

    if (master_encryption_key.size() != 256 / 8) {
      ldpp_dout(s, 0) << "ERROR: failed to decode 'rgw crypt default encryption key' to 256 bit string" << dendl;
      return -EIO;
    }
    std::string attr_key_selector = get_str_attribute(attrs, RGW_ATTR_CRYPT_KEYSEL);
    if (attr_key_selector.size() != AES_256_CBC::AES_256_KEYSIZE) {
      ldpp_dout(s, 0) << "ERROR: missing or invalid " RGW_ATTR_CRYPT_KEYSEL << dendl;
      return -EIO;
    }
    uint8_t actual_key[AES_256_KEYSIZE];
    if (AES_256_ECB_encrypt(s, s->cct,
                            reinterpret_cast<const uint8_t*>(master_encryption_key.c_str()),
                            AES_256_KEYSIZE,
                            reinterpret_cast<const uint8_t*>(attr_key_selector.c_str()),
                            actual_key, AES_256_KEYSIZE) != true) {
      ::ceph::crypto::zeroize_for_security(actual_key, sizeof(actual_key));
      return -EIO;
    }
    auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
    aes->set_key(actual_key, AES_256_KEYSIZE);
    ::ceph::crypto::zeroize_for_security(actual_key, sizeof(actual_key));
    if (block_crypt) *block_crypt = std::move(aes);
    return 0;
  }

  if (stored_mode == "RGW-AUTO-GCM") {
    std::string master_encryption_key;
    try {
      master_encryption_key = from_base64(std::string(s->cct->_conf->rgw_crypt_default_encryption_key));
    } catch (...) {
      ldpp_dout(s, 5) << "ERROR: rgw_s3_prepare_decrypt invalid default encryption key "
                       << "which contains character that is not base64 encoded."
                       << dendl;
      s->err.message = "The default encryption key is not valid base64.";
      return -EINVAL;
    }

    if (master_encryption_key.size() != 256 / 8) {
      ldpp_dout(s, 0) << "ERROR: failed to decode 'rgw crypt default encryption key' to 256 bit string" << dendl;
      return -EIO;
    }

    // Retrieve the stored nonce for decryption
    std::string stored_nonce = get_str_attribute(attrs, RGW_ATTR_CRYPT_NONCE);
    if (stored_nonce.size() != AES_256_GCM_NONCE_SIZE) {
      ldpp_dout(s, 5) << "ERROR: Missing or invalid nonce for RGW-AUTO-GCM decryption" << dendl;
      s->err.message = "Object encryption metadata is corrupted.";
      return -EIO;
    }

    // Create GCM instance with stored nonce
    auto gcm = std::unique_ptr<AES_256_GCM>(new AES_256_GCM(s, s->cct));
    if (!gcm->set_nonce(reinterpret_cast<const uint8_t*>(stored_nonce.c_str()),
                        stored_nonce.size())) {
      ldpp_dout(s, 5) << "ERROR: RGW-AUTO-GCM decryption: stored nonce has invalid size "
                       << stored_nonce.size() << " (expected " << AES_256_GCM_NONCE_SIZE << ")" << dendl;
      s->err.message = "Object encryption metadata is corrupted.";
      return -EIO;
    }

    // Re-derive encryption key using HMAC-SHA256 with context binding
    // For CopyObject, use the SOURCE object's identity (not destination)
    std::string bucket_name;
    std::string object_name;
    std::string version_id;
    if (copy_source && s->src_object) {
      bucket_name = s->src_bucket_name;
      object_name = s->src_object->get_name();
      version_id = s->src_object->get_instance();
    } else {
      bucket_name = s->bucket->get_name();
      object_name = s->object->get_name();
      version_id = s->object ? s->object->get_instance() : "";
    }

    if (!gcm->derive_object_key(
            reinterpret_cast<const uint8_t*>(master_encryption_key.c_str()),
            AES_256_KEYSIZE,
            bucket_name,
            object_name,
            version_id,
            "",  // no user context for RGW-AUTO
            part_number,
            "RGW-AUTO-GCM")) {
      ldpp_dout(s, 5) << "ERROR: RGW-AUTO-GCM key derivation failed for "
                       << bucket_name << "/" << object_name << dendl;
      s->err.message = "Failed to derive decryption key.";
      return -EIO;
    }

    if (block_crypt) *block_crypt = std::move(gcm);
    return 0;
  }

  /* SSE-S3 */
  if (stored_mode == "AES256") {
    /* try to retrieve actual key */
    std::string key_id = get_str_attribute(attrs, RGW_ATTR_CRYPT_KEYID);
    std::string actual_key;
    res = reconstitute_actual_key_from_sse_s3(s, attrs, y, actual_key);
    if (res != 0) {
      ldpp_dout(s, 10) << "ERROR: failed to retrieve actual key" << dendl;
      s->err.message = "Failed to retrieve the actual key";
      return res;
    }
    if (actual_key.size() != AES_256_KEYSIZE) {
      ldpp_dout(s, 0) << "ERROR: key obtained " <<
          "is not 256 bit size" << dendl;
      s->err.message = "SSE-S3 provided an invalid key for the given keyid.";
      return -EINVAL;
    }

    auto aes = std::unique_ptr<AES_256_CBC>(new AES_256_CBC(s, s->cct));
    aes->set_key(reinterpret_cast<const uint8_t*>(actual_key.c_str()), AES_256_KEYSIZE);
    actual_key.replace(0, actual_key.length(), actual_key.length(), '\000');
    if (block_crypt) *block_crypt = std::move(aes);

    if (crypt_http_responses) {
      crypt_http_responses->emplace("x-amz-server-side-encryption", "AES256");
    }

    return 0;
  }

  /* SSE-S3 with GCM */
  if (stored_mode == "AES256-GCM") {
    /* try to retrieve actual key */
    std::string key_id = get_str_attribute(attrs, RGW_ATTR_CRYPT_KEYID);
    std::string actual_key;
    res = reconstitute_actual_key_from_sse_s3(s, attrs, y, actual_key);
    if (res != 0) {
      ldpp_dout(s, 10) << "ERROR: failed to retrieve actual key" << dendl;
      s->err.message = "Failed to retrieve the actual key";
      return res;
    }
    if (actual_key.size() != AES_256_KEYSIZE) {
      ldpp_dout(s, 0) << "ERROR: key obtained " <<
          "is not 256 bit size" << dendl;
      s->err.message = "SSE-S3 provided an invalid key for the given keyid.";
      return -EINVAL;
    }

    // Retrieve the stored nonce for decryption
    std::string stored_nonce = get_str_attribute(attrs, RGW_ATTR_CRYPT_NONCE);
    if (stored_nonce.size() != AES_256_GCM_NONCE_SIZE) {
      ldpp_dout(s, 5) << "ERROR: Missing or invalid nonce for AES256-GCM decryption" << dendl;
      actual_key.replace(0, actual_key.length(), actual_key.length(), '\000');
      s->err.message = "Object encryption metadata is corrupted.";
      return -EIO;
    }

    auto aes = AES_256_GCM_create(s, s->cct,
                                   reinterpret_cast<const uint8_t*>(actual_key.c_str()),
                                   AES_256_KEYSIZE,
                                   reinterpret_cast<const uint8_t*>(stored_nonce.c_str()),
                                   stored_nonce.size(),
                                   part_number);
    actual_key.replace(0, actual_key.length(), actual_key.length(), '\000');
    if (!aes) {
      ldpp_dout(s, 5) << "ERROR: Failed to create AES-256-GCM instance for decryption" << dendl;
      return -EIO;
    }
    if (block_crypt) *block_crypt = std::move(aes);

    if (crypt_http_responses) {
      crypt_http_responses->emplace("x-amz-server-side-encryption", "AES256");
    }

    return 0;
  }

  /*no decryption*/
  return 0;
}

int rgw_remove_sse_s3_bucket_key(req_state *s, optional_yield y)
{
  int res;
  auto key_id { expand_key_name(s, s->cct->_conf->rgw_crypt_sse_s3_key_template) };
  auto saved_key { fetch_bucket_key_id(s) };
  size_t i;

  if (key_id == cant_expand_key) {
    ldpp_dout(s, 5) << "ERROR: unable to expand key_id " <<
      s->cct->_conf->rgw_crypt_sse_s3_key_template << " on bucket" << dendl;
    s->err.message = "Server side error - unable to expand key_id";
    return -EINVAL;
  }

  if (saved_key == "") {
    return 0;
  } else if (saved_key != key_id) {
    ldpp_dout(s, 5) << "Found but will not delete strange KEK ID: " << saved_key << dendl;
    return 0;
  }
  i = s->cct->_conf->rgw_crypt_sse_s3_key_template.find("%bucket_id");
  if (i == std::string_view::npos) {
    ldpp_dout(s, 5) << "Kept valid KEK ID: " << saved_key << dendl;
    return 0;
  }
  ldpp_dout(s, 5) << "Removing valid KEK ID: " << saved_key << dendl;
  res = remove_sse_s3_bucket_key(s, saved_key, y);
  if (res != 0) {
    ldpp_dout(s, 0) << "ERROR: Unable to remove KEK ID: " << saved_key << " got " << res << dendl;
  }
  return res;
}

/*********************************************************************
*	"BOTTOM OF FILE"
*	I've left some commented out lines above.  They are there for
*	a reason, which I will explain.  The "canonical" json constructed
*	by the code above as a crypto context must take a json object and
*	turn it into a unique deterministic fixed form.  For most json
*	types this is easy.  The hardest problem that is handled above is
*	detailing with unicode strings; they must be turned into
*	NFC form and sorted in a fixed order.  Numbers, however,
*	are another story.  Json makes no distinction between integers
*	and floating point, and both types have their problems.
*	Integers can overflow, so very large numbers are a problem.
*	Floating point is even worse; not all floating point numbers
*	can be represented accurately in c++ data types, and there
*	are many quirks regarding how overflow, underflow, and loss
*	of significance are handled.
*
*	In this version of the code, I took the simplest answer, I
*	reject all numbers altogether.  This is not ideal, but it's
*	the only choice that is guaranteed to be future compatible.
*	AWS S3 does not guarantee to support numbers at all; but it
*	actually converts all numbers into strings right off.
*	This has the interesting property that 7 and 007 are different,
*	but that 007 and "007" are the same.  I would rather
*	treat numbers as a string of digits and have logic
*	to produce the "most compact" equivalent form.  This can
*	fix all the overflow/underflow problems, but it requires
*	fixing the json parser part, and I put that problem off.
*
*	The commented code above indicates places in this code that
*	will need to be revised depending on future work in this area.
*	Removing those comments makes that work harder.
*				February 25, 2021
*********************************************************************/
